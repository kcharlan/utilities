<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gorilla.BAS Web</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #0b1222;
      --panel-strong: #0a1329;
      --accent: #ffcc4d;
      --accent-2: #60a5fa;
      --text: #e2e8f0;
      --muted: #8ea0c5;
      --danger: #ef4444;
      --success: #10b981;
      --shadow: 0 15px 40px rgba(0, 0, 0, 0.35);
      --border: 1px solid rgba(255, 255, 255, 0.08);
      --radius: 12px;
      --font: "Futura", "Gill Sans", "Trebuchet MS", "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, rgba(96, 165, 250, 0.12), transparent 35%), radial-gradient(circle at 80% 10%, rgba(239, 68, 68, 0.18), transparent 30%), var(--bg);
      color: var(--text);
      font-family: var(--font);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header.hud {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 14px 18px;
      background: rgba(9, 12, 24, 0.88);
      border-bottom: var(--border);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .hud .title {
      font-weight: 700;
      letter-spacing: 0.04em;
      font-size: 18px;
    }

    .pill {
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      border: var(--border);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
    }

    .wind-arrow {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transform: rotate(0deg);
      color: var(--accent);
      transition: transform 0.3s ease, color 0.3s ease;
    }

    .scoreboard {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }

    .turn-indicator {
      padding: 8px 12px;
      border-radius: 10px;
      background: linear-gradient(120deg, rgba(255, 204, 77, 0.15), rgba(96, 165, 250, 0.12));
      border: var(--border);
      color: var(--text);
      font-weight: 600;
    }

    .layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 14px;
      padding: 14px 14px 22px;
      flex: 1;
    }

    aside.sidebar {
      background: rgba(11, 18, 34, 0.9);
      border: var(--border);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      overflow: hidden;
    }

    aside.sidebar.locked {
      opacity: 0.5;
      pointer-events: none;
      filter: grayscale(0.4);
    }

    .sidebar h3 {
      margin: 0 0 8px;
      font-size: 16px;
      letter-spacing: 0.02em;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 10px;
      padding: 10px;
      border: var(--border);
    }

    .mode-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .mode-options label {
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
    }

    label {
      font-size: 13px;
      color: var(--muted);
    }

    select,
    input[type="number"],
    input[type="range"] {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: var(--font);
      transition: border-color 0.2s ease, transform 0.15s ease;
    }

    select:focus,
    input:focus {
      outline: none;
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    button {
      background: linear-gradient(120deg, #fbbf24, #f97316);
      color: #0f172a;
      border: none;
      padding: 12px 14px;
      border-radius: 10px;
      font-weight: 700;
      letter-spacing: 0.01em;
      cursor: pointer;
      box-shadow: 0 10px 25px rgba(249, 115, 22, 0.35);
      transition: transform 0.1s ease, box-shadow 0.2s ease;
      font-family: var(--font);
    }

    button:hover {
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .button-secondary {
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .game-shell {
      background: rgba(12, 17, 30, 0.92);
      border-radius: var(--radius);
      border: var(--border);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .canvas-wrap {
      position: relative;
      flex: 1;
      min-height: 420px;
      background: linear-gradient(180deg, #0b1b38 0%, #0a1222 55%, #0b0f1b 100%);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .floating-message {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(15, 23, 42, 0.8);
      border: var(--border);
      padding: 10px 14px;
      border-radius: 10px;
      color: var(--muted);
      font-size: 13px;
      backdrop-filter: blur(8px);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      padding: 14px;
      background: rgba(8, 13, 26, 0.9);
      border-top: var(--border);
    }

    .controls.disabled {
      opacity: 0.5;
      filter: grayscale(0.5);
      pointer-events: none;
    }

    .controls.controls-locked {
      opacity: 0.5;
      pointer-events: none;
      filter: grayscale(0.5);
    }

    .counterfire-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .counterfire-controls.hidden {
      display: none;
    }

    .player-panel {
      border: var(--border);
      border-radius: 10px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .player-panel.active {
      border-color: var(--accent);
      box-shadow: inset 0 0 0 1px rgba(255, 204, 77, 0.25);
    }

    .player-panel button {
      width: 100%;
      padding: 10px;
    }

    .counterfire-status {
      font-size: 13px;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 8px;
      border: var(--border);
      background: rgba(255, 255, 255, 0.02);
    }

    .controls .field {
      height: 100%;
    }

    .input-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .last-shot {
      color: var(--muted);
      font-size: 13px;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }

    .hud-toggle {
      margin-left: auto;
      display: none;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    @media (max-width: 980px) {
      .layout {
        grid-template-columns: 1fr;
      }

      aside.sidebar {
        position: fixed;
        inset: 0 0 0 30%;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        z-index: 20;
        max-width: 360px;
      }

      aside.sidebar.open {
        transform: translateX(0);
      }

      .hud-toggle {
        display: inline-flex;
      }
    }

    @media (max-width: 680px) {
      aside.sidebar {
        inset: 0;
      }

      header.hud {
        flex-wrap: wrap;
        gap: 10px;
      }
    }

    .round-banner {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.02em;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.55));
      color: var(--text);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .round-banner.visible {
      opacity: 1;
    }
  </style>
</head>

<body>
  <div id="app">
    <header class="hud">
      <div class="title">Gorilla.BAS Web</div>
      <div class="pill" aria-live="polite">
        <span class="wind-arrow" id="windArrow">➜</span>
        <span id="windText">Wind: 0</span>
      </div>
      <div class="pill scoreboard" aria-live="polite">
        <span id="scoreP1">P1-0(0)</span>
        <span>—</span>
        <span id="scoreP2">P2-0(0)</span>
      </div>
      <div class="turn-indicator" id="turnIndicator">Player 1's Turn</div>
      <button class="hud-toggle" id="sidebarToggle" aria-label="Toggle settings sidebar">Settings</button>
    </header>

    <div class="layout">
      <aside class="sidebar" id="sidebar" aria-label="Settings">
        <h3>Settings</h3>
        <div class="field">
          <label>Game Mode</label>
          <div class="mode-options" role="radiogroup" aria-label="Game mode">
            <label><input type="radio" name="gameMode" value="classic" checked> Classic</label>
            <label><input type="radio" name="gameMode" value="demo"> Demo</label>
            <label><input type="radio" name="gameMode" value="arcade"> Arcade</label>
          </div>
        </div>
        <div class="field">
          <label for="opponentSelect">Opponent Type</label>
          <select id="opponentSelect">
            <option value="ai">Vs AI</option>
            <option value="local">Local 2-Player</option>
          </select>
        </div>
        <div class="field">
          <label><input type="checkbox" id="counterfireToggle"> Counterfire</label>
        </div>
        <div class="field">
          <label for="aiDifficulty">AI Difficulty</label>
          <select id="aiDifficulty">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        <div class="field">
          <label for="gravitySelect">Gravity</label>
          <select id="gravitySelect">
            <option value="low">Low</option>
            <option value="normal" selected>Normal</option>
            <option value="high">High</option>
          </select>
        </div>
        <div class="field">
          <label for="windSelect">Wind</label>
          <select id="windSelect">
            <option value="off">Off</option>
            <option value="low" selected>Low</option>
            <option value="high">High</option>
          </select>
        </div>
        <div class="field">
          <label><input type="checkbox" id="muteToggle"> Mute Sounds</label>
        </div>
        <div class="field">
          <label for="varianceSelect">Skyline Variance</label>
          <select id="varianceSelect">
            <option value="low">Low</option>
            <option value="normal" selected>Normal</option>
            <option value="high">High</option>
          </select>
        </div>
        <div class="field">
          <label>Help</label>
          <div style="color: var(--muted); font-size: 13px; line-height: 1.5;">
            Enter an angle (0–180°) and velocity, then throw. Off-screen shots continue to simulate and can re-enter the
            view. Press <strong>R</strong> to restart the round.
          </div>
        </div>
      </aside>

      <section class="game-shell">
        <div class="canvas-wrap">
          <canvas id="gameCanvas" aria-label="Gorilla battlefield"></canvas>
          <div class="floating-message" id="messageBox">Generate a skyline and start throwing!</div>
          <div class="round-banner" id="roundBanner" aria-live="assertive"></div>
        </div>
        <form class="controls" id="controlForm">
          <div id="singleControls">
            <div class="field">
              <label for="angleInput">Angle (0–180°)</label>
              <div class="input-row">
                <input type="number" id="angleInput" min="0" max="180" value="60" aria-label="Angle in degrees">
                <input type="range" id="angleSlider" min="0" max="180" value="60" aria-label="Angle slider">
              </div>
            </div>
            <div class="field">
              <label for="velocityInput">Velocity (5–100)</label>
              <div class="input-row">
                <input type="number" id="velocityInput" min="5" max="100" value="55" aria-label="Velocity units">
                <input type="range" id="velocitySlider" min="5" max="100" value="55" aria-label="Velocity slider">
              </div>
            </div>
          </div>
          <div class="counterfire-controls hidden" id="counterfireControls">
            <div class="player-panel" id="counterfirePlayer1" data-player="1">
              <label for="cfAngleInput1">Player 1 Angle</label>
              <div class="input-row">
                <input type="number" id="cfAngleInput1" min="0" max="180" value="60" aria-label="Player 1 angle">
                <input type="range" id="cfAngleSlider1" min="0" max="180" value="60" aria-label="Player 1 angle slider">
              </div>
              <label for="cfVelocityInput1">Player 1 Velocity</label>
              <div class="input-row">
                <input type="number" id="cfVelocityInput1" min="5" max="100" value="55" aria-label="Player 1 velocity">
                <input type="range" id="cfVelocitySlider1" min="5" max="100" value="55" aria-label="Player 1 velocity slider">
              </div>
              <button type="button" class="counterfireThrow" data-player="1">Player 1 Throw</button>
            </div>
            <div class="player-panel" id="counterfirePlayer2" data-player="2">
              <label for="cfAngleInput2">Player 2 Angle</label>
              <div class="input-row">
                <input type="number" id="cfAngleInput2" min="0" max="180" value="60" aria-label="Player 2 angle">
                <input type="range" id="cfAngleSlider2" min="0" max="180" value="60" aria-label="Player 2 angle slider">
              </div>
              <label for="cfVelocityInput2">Player 2 Velocity</label>
              <div class="input-row">
                <input type="number" id="cfVelocityInput2" min="5" max="100" value="55" aria-label="Player 2 velocity">
                <input type="range" id="cfVelocitySlider2" min="5" max="100" value="55" aria-label="Player 2 velocity slider">
              </div>
              <button type="button" class="counterfireThrow" data-player="2">Player 2 Throw</button>
            </div>
            <div class="counterfire-status" id="counterfireStatus">Waiting for Player 1</div>
          </div>
          <div class="field">
            <label aria-live="polite">Last Shot</label>
            <div class="last-shot" id="lastShotText">P1: 60° @ 55</div>
          </div>
          <div class="field" style="gap:8px;">
            <label>&nbsp;</label>
            <div class="input-row" style="gap:6px;">
              <button type="submit" id="primaryThrowBtn">Throw</button>
              <button type="button" class="button-secondary" id="newRoundBtn">New Round</button>
              <button type="button" class="button-secondary" id="resetScoresBtn">Reset Scores</button>
            </div>
          </div>
        </form>
      </section>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const hudWind = document.getElementById('windText');
      const windArrow = document.getElementById('windArrow');
      const scoreP1 = document.getElementById('scoreP1');
      const scoreP2 = document.getElementById('scoreP2');
      const turnIndicator = document.getElementById('turnIndicator');
      const messageBox = document.getElementById('messageBox');
      const roundBanner = document.getElementById('roundBanner');

      const angleInput = document.getElementById('angleInput');
      const angleSlider = document.getElementById('angleSlider');
      const velocityInput = document.getElementById('velocityInput');
      const velocitySlider = document.getElementById('velocitySlider');
      const lastShotText = document.getElementById('lastShotText');
      const controlForm = document.getElementById('controlForm');
      const primaryThrowBtn = document.getElementById('primaryThrowBtn');
      const newRoundBtn = document.getElementById('newRoundBtn');
      const resetScoresBtn = document.getElementById('resetScoresBtn');
      const sidebar = document.getElementById('sidebar');
      const sidebarToggle = document.getElementById('sidebarToggle');

      const opponentSelect = document.getElementById('opponentSelect');
      const counterfireToggle = document.getElementById('counterfireToggle');
      const counterfireControls = document.getElementById('counterfireControls');
      const counterfireStatus = document.getElementById('counterfireStatus');
      const cfAngleInput1 = document.getElementById('cfAngleInput1');
      const cfAngleSlider1 = document.getElementById('cfAngleSlider1');
      const cfVelocityInput1 = document.getElementById('cfVelocityInput1');
      const cfVelocitySlider1 = document.getElementById('cfVelocitySlider1');
      const cfAngleInput2 = document.getElementById('cfAngleInput2');
      const cfAngleSlider2 = document.getElementById('cfAngleSlider2');
      const cfVelocityInput2 = document.getElementById('cfVelocityInput2');
      const cfVelocitySlider2 = document.getElementById('cfVelocitySlider2');
      const cfPlayerPanel1 = document.getElementById('counterfirePlayer1');
      const cfPlayerPanel2 = document.getElementById('counterfirePlayer2');
      const singleControls = document.getElementById('singleControls');
      const aiDifficultySelect = document.getElementById('aiDifficulty');
      const gravitySelect = document.getElementById('gravitySelect');
      const windSelect = document.getElementById('windSelect');
      const varianceSelect = document.getElementById('varianceSelect');
      const gameModeRadios = document.querySelectorAll('input[name="gameMode"]');
      const counterfirePanels = {
        1: {
          angleInput: cfAngleInput1,
          angleSlider: cfAngleSlider1,
          velocityInput: cfVelocityInput1,
          velocitySlider: cfVelocitySlider1,
          panel: cfPlayerPanel1,
          button: cfPlayerPanel1.querySelector('.counterfireThrow[data-player="1"]')
        },
        2: {
          angleInput: cfAngleInput2,
          angleSlider: cfAngleSlider2,
          velocityInput: cfVelocityInput2,
          velocitySlider: cfVelocitySlider2,
          panel: cfPlayerPanel2,
          button: cfPlayerPanel2.querySelector('.counterfireThrow[data-player="2"]')
        }
      };

      const world = {
        width: 2200,
        height: 1200,
        groundY: 1100
      };

      const MIN_BUILDING_HEIGHT = 180;
      const MAX_BUILDING_HEIGHT = 780;

      const gorillaSize = { width: 90, height: 105 };
      const bananaRadius = 14; // Slightly larger banana for better readability
      const explosionDuration = 650;
      const maxFlightSeconds = 12;
      const velocityScale = 11; // Converts player velocity units to world units/sec.

      // FIXED TIME STEP CONSTANTS
      const SIM_DT = 0.015; // 15ms per physics tick
      let accumulator = 0;

      const settings = {
        opponentType: 'ai',
        gameMode: 'classic',
        aiDifficulty: 'medium',
        gravityLevel: 'normal',
        windMode: 'low',
        skylineVariance: 'normal',
        counterfire: false
      };

      const aiPlan = { shots: [] };

      const lastShot = {
        1: { angle: 60, velocity: 55 },
        2: { angle: 60, velocity: 55 }
      };

      const state = {
        currentPlayer: 1,
        scores: { 1: 0, 2: 0 },
        aces: { 1: 0, 2: 0 },
        playerShotsThisRound: { 1: 0, 2: 0 },
        buildings: [],
        gorillas: [],
        wind: 0,
        gravity: 70,
        bananas: [],
        inFlight: false,
        explosion: null,
        roundActive: true,
        shotsTakenThisRound: 0
      };

      let lastPlacement = null;

      const pendingCounterfireShots = { 1: null, 2: null };
      let counterfireActiveEntry = 1;
      let resolutionBuffer = [];
      let volleyDeadTargets = new Set();

      let lastFrame = performance.now();

      const gravityLevels = { low: 55, normal: 70, high: 90 };
      const windLevels = { off: 0, low: 15, high: 30 };
      const varianceLevels = { low: 0.12, normal: 0.28, high: 0.48 };

      opponentSelect.value = settings.opponentType;
      gameModeRadios.forEach(radio => {
        radio.checked = radio.value === settings.gameMode;
      });
      counterfireToggle.checked = settings.counterfire;
      aiDifficultySelect.value = settings.aiDifficulty;

      const gorillaSprites = createGorillaSprites();
      const soundPlayer = createSoundPlayer();

      function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = Math.max(420, canvas.clientHeight || 520);
      }

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      let nextRoundTimeout = null;
      let nextRoundInterval = null;
      let nextRoundCountdown = 0;
      let aiTimeout = null;

      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function simulateShot(angleDeg, velocity, shooter, target) {
        const rad = angleDeg * Math.PI / 180;
        const vx0 = Math.cos(rad) * velocity * velocityScale * shooter.facing;
        const vy0 = -Math.sin(rad) * velocity * velocityScale;
        const banana = {
          x: shooter.x + (gorillaSize.width / 2 + bananaRadius + 4) * shooter.facing,
          y: shooter.y - gorillaSize.height - bananaRadius * 2,
          vx: vx0,
          vy: vy0,
          elapsed: 0
        };

        const targetRect = {
          x: target.x - gorillaSize.width / 2,
          y: target.y - gorillaSize.height,
          w: gorillaSize.width,
          h: gorillaSize.height
        };

        const maxSimTime = 9;
        for (let t = 0; t < maxSimTime; t += SIM_DT) {
          advancePhysicsStep(banana, SIM_DT);
          const x = banana.x;
          const y = banana.y;

          for (const b of state.buildings) {
            const topY = world.groundY - b.height;
            if (x + bananaRadius > b.x && x - bananaRadius < b.x + b.width &&
              y + bananaRadius > topY && y - bananaRadius < world.groundY) {
              return { hit: false, reason: 'building' };
            }
          }

          if (x + bananaRadius > targetRect.x && x - bananaRadius < targetRect.x + targetRect.w &&
            y + bananaRadius > targetRect.y && y - bananaRadius < targetRect.y + targetRect.h) {
            return { hit: true, angle: angleDeg, velocity };
          }

          if (y > world.groundY + 200 || x < -400 || x > world.width + 400) {
            return { hit: false, reason: 'out' };
          }
        }
        return { hit: false, reason: 'timeout' };
      }

      function computeOptimalShot(shooter, target) {
        let best = null;
        let bestMiss = Infinity;
        for (let velocity = 20; velocity <= 100; velocity += 2) {
          for (let angle = 10; angle <= 85; angle += 1) {
            const res = simulateShot(angle, velocity, shooter, target);
            if (res.hit) return { angle, velocity };
            // crude miss metric: distance to target center in x
            const miss = Math.abs(target.x - (shooter.x + Math.cos(angle * Math.PI / 180) * velocity));
            if (miss < bestMiss) {
              bestMiss = miss;
              best = { angle, velocity };
            }
          }
        }
        return best || { angle: 45, velocity: 60 };
      }

      function buildAiPlan(shooter, target) {
        const solution = computeOptimalShot(shooter, target);
        const difficulty = settings.aiDifficulty;
        let missCount = 0;
        if (difficulty === 'hard') {
          missCount = Math.floor(Math.random() * 3); // 0-2
        } else if (difficulty === 'medium') {
          missCount = Math.floor(Math.random() * 6); // 0-5
        } else {
          missCount = Math.floor(Math.random() * 8) + 3; // 3-10
        }

        const shots = [];
        if (missCount === 0) {
          shots.push(solution);
          return shots;
        }

        const offsetSign = Math.random() < 0.5 ? -1 : 1;
        let startOffset;
        if (difficulty === 'hard') {
          startOffset = rand(1, 6) * offsetSign;
        } else if (difficulty === 'medium') {
          startOffset = rand(3, 10) * offsetSign;
        } else {
          startOffset = rand(6, 15) * offsetSign;
        }

        for (let i = 0; i < missCount; i++) {
          const factor = (missCount - i) / missCount; // strictly decreases toward 0
          const offset = startOffset * factor;
          shots.push({
            angle: clamp(solution.angle + offset * 0.2, 10, 85),
            velocity: clamp(solution.velocity + offset, 5, 100)
          });
        }

        shots.push(solution);
        return shots;
      }

      function setMessage(text) {
        messageBox.textContent = text;
      }

      function playSound(name) {
        if (muteToggle.checked) return;
        soundPlayer.play(name);
      }

      function setControlsEnabled(enabled) {
        controlForm.classList.toggle('disabled', !enabled);
        controlForm.querySelectorAll('input, button').forEach(el => {
          el.disabled = !enabled;
        });
      }

      function setSettingsEnabled(enabled) {
        sidebar.classList.toggle('locked', !enabled);
        controlForm.classList.toggle('controls-locked', !enabled);
        sidebar.querySelectorAll('select, input').forEach(el => {
          el.disabled = !enabled;
        });
      }

      function syncCounterfireInputsFromLast() {
        for (const player of [1, 2]) {
          const info = lastShot[player];
          const cfg = counterfirePanels[player];
          cfg.angleInput.value = info.angle;
          cfg.angleSlider.value = info.angle;
          cfg.velocityInput.value = info.velocity;
          cfg.velocitySlider.value = info.velocity;
        }
      }

      function updateCounterfirePanelStates() {
        const bothPending = Boolean(pendingCounterfireShots[1] && pendingCounterfireShots[2]);
        for (const player of [1, 2]) {
          const cfg = counterfirePanels[player];
          const isAIPlayer = settings.opponentType === 'ai' && player === 2;
          cfg.panel.hidden = isAIPlayer;
          const hasShot = Boolean(pendingCounterfireShots[player]);
          const shouldEnable = settings.counterfire && !hasShot && !bothPending && counterfireActiveEntry === player && !isAIPlayer;
          const disabled = !shouldEnable;
          cfg.angleInput.disabled = disabled;
          cfg.angleSlider.disabled = disabled;
          cfg.velocityInput.disabled = disabled;
          cfg.velocitySlider.disabled = disabled;
          cfg.button.disabled = disabled;
          cfg.panel.classList.toggle('active', shouldEnable);
        }
        if (!settings.counterfire) {
          counterfireStatus.textContent = '';
        } else if (pendingCounterfireShots[1] && pendingCounterfireShots[2]) {
          counterfireStatus.textContent = 'Counterfire volley launched!';
        } else {
          counterfireStatus.textContent = `Waiting for Player ${counterfireActiveEntry}`;
        }
      }

      function refreshCounterfireUI() {
        const enabled = settings.counterfire;
        singleControls.hidden = enabled;
        counterfireControls.classList.toggle('hidden', !enabled);
        controlForm.classList.toggle('counterfire-active', enabled);
        primaryThrowBtn.hidden = enabled;
        if (!enabled) {
          counterfireStatus.textContent = '';
          return;
        }
        updateCounterfirePanelStates();
      }

      function resetCounterfireEntry() {
        pendingCounterfireShots[1] = null;
        pendingCounterfireShots[2] = null;
        counterfireActiveEntry = settings.counterfire ? 1 : state.currentPlayer;
        volleyDeadTargets.clear();
        resolutionBuffer = [];
        syncCounterfireInputsFromLast();
        refreshCounterfireUI();
      }

      function showRoundBanner(text) {
        roundBanner.textContent = text;
        roundBanner.classList.add('visible');
      }

      function hideRoundBanner() {
        roundBanner.classList.remove('visible');
        roundBanner.textContent = '';
      }

      function regenerateRound(resetTurn = false) {
        if (nextRoundTimeout) {
          clearTimeout(nextRoundTimeout);
          nextRoundTimeout = null;
        }
        if (nextRoundInterval) {
          clearInterval(nextRoundInterval);
          nextRoundInterval = null;
        }
        if (aiTimeout) {
          clearTimeout(aiTimeout);
          aiTimeout = null;
        }
        aiPlan.shots = [];
        const variance = varianceLevels[settings.skylineVariance];
        const layout = attemptGorillaPlacement(variance);
        state.buildings = layout.buildings;
        state.gorillas = layout.result.gorillas;
        lastPlacement = {
          left: layout.result.leftPlacement,
          right: layout.result.rightPlacement,
          delta: layout.result.delta
        };
        state.gravity = gravityLevels[settings.gravityLevel];

        const windBound = windLevels[settings.windMode];
        state.wind = windBound === 0 ? 0 : rand(-windBound, windBound);
        state.bananas = [];
        state.explosion = null;
        state.inFlight = false;
        state.roundActive = true;
        state.shotsTakenThisRound = 0;
        state.playerShotsThisRound[1] = 0;
        state.playerShotsThisRound[2] = 0;
        setControlsEnabled(true);
        setSettingsEnabled(true);
        updateModeDependentControls();
        resetCounterfireEntry();
        hideRoundBanner();
        if (resetTurn) state.currentPlayer = 1;
        updateHUD();
        setInputsFromLast();
        setMessage('New skyline ready. Aim carefully!');
        if (settings.opponentType === 'ai') maybeTriggerAI();
      }

      function generateBuildings(variance) {
        const buildings = [];
        let x = 0;
        while (x < world.width) {
          const w = rand(140, 220);
          const base = 280;
          const height = clamp(base * (1 + rand(-variance, variance)) + rand(60, 220), 180, 620);
          buildings.push({
            x,
            width: w,
            height,
            color: `hsl(${rand(200, 230)}, ${rand(28, 46)}%, ${rand(25, 40)}%)`
          });
          x += w + rand(-12, 14);
        }
        return buildings;
      }

      function placeGorillas(buildings, previousPlacement = null, forceVariation = false) {
        const edgeMargin = 220;
        const band = 320;
        const findLeft = () => {
          const candidates = buildings.map((b, idx) => ({ idx, center: b.x + b.width / 2 }))
            .filter(c => c.center >= edgeMargin && c.center <= edgeMargin + band);
          if (candidates.length) return candidates[Math.floor(Math.random() * candidates.length)].idx;
          const fallback = buildings.map((b, idx) => ({ idx, center: b.x + b.width / 2, delta: Math.abs((b.x + b.width / 2) - edgeMargin) }));
          fallback.sort((a, b) => a.delta - b.delta);
          return fallback[0].idx;
        };
        const findRight = () => {
          const targetStart = world.width - edgeMargin - band;
          const targetEnd = world.width - edgeMargin;
          const candidates = buildings.map((b, idx) => ({ idx, center: b.x + b.width / 2 }))
            .filter(c => c.center >= targetStart && c.center <= targetEnd);
          if (candidates.length) return candidates[Math.floor(Math.random() * candidates.length)].idx;
          const fallback = buildings.map((b, idx) => ({ idx, center: b.x + b.width / 2, delta: Math.abs((b.x + b.width / 2) - targetEnd) }));
          fallback.sort((a, b) => a.delta - b.delta);
          return fallback[0].idx;
        };

        const leftIndex = findLeft();
        let rightIndex = findRight();
        if (rightIndex <= leftIndex + 4) rightIndex = clamp(leftIndex + 5, 0, buildings.length - 1);

        const pick = (idx, isLeft) => {
          const b = buildings[clamp(idx, 0, buildings.length - 1)];
          return {
            x: b.x + b.width / 2,
            y: world.groundY - b.height,
            buildingIndex: idx,
            facing: isLeft ? 1 : -1
          };
        };

        const buildPlacement = () => {
          const leftGorilla = pick(leftIndex, true);
          const rightGorilla = pick(rightIndex, false);
          const leftBuilding = buildings[clamp(leftIndex, 0, buildings.length - 1)];
          const rightBuilding = buildings[clamp(rightIndex, 0, buildings.length - 1)];
          const dx = Math.abs(rightGorilla.x - leftGorilla.x);
          const dy = Math.abs(leftBuilding.height - rightBuilding.height);
          return { gorillas: [leftGorilla, rightGorilla], leftBuilding, rightBuilding, dx, dy };
        };

        enforceMidObstacle(buildings, leftIndex, rightIndex);
        let placement = buildPlacement();

        let variationSatisfied = true;
        if (previousPlacement) {
          const baseDx = previousPlacement.delta.dx || placement.dx || 1;
          const baseDy = previousPlacement.delta.dy || placement.dy || 1;
          const dxChange = Math.abs(placement.dx - previousPlacement.delta.dx) / baseDx;
          const dyChange = Math.abs(placement.dy - previousPlacement.delta.dy) / baseDy;
          variationSatisfied = dxChange >= 0.2 && dyChange >= 0.2;
        }

        if (!variationSatisfied && forceVariation && previousPlacement) {
          applyHeightVariation(placement.leftBuilding, previousPlacement.left.height);
          applyHeightVariation(placement.rightBuilding, previousPlacement.right.height);
          rightIndex = shiftRightPlacement(buildings, leftIndex, rightIndex);
          enforceMidObstacle(buildings, leftIndex, rightIndex);
          placement = buildPlacement();
          variationSatisfied = true;
        }

        const gorillas = placement.gorillas;
        const result = {
          gorillas,
          delta: { dx: placement.dx, dy: placement.dy },
          variationSatisfied,
          leftPlacement: {
            x: gorillas[0].x,
            y: gorillas[0].y,
            height: placement.leftBuilding.height
          },
          rightPlacement: {
            x: gorillas[1].x,
            y: gorillas[1].y,
            height: placement.rightBuilding.height
          }
        };
        return result;
      }

      function applyHeightVariation(building, previousHeight) {
        if (!previousHeight) return;
        const baseline = Math.max(previousHeight, MIN_BUILDING_HEIGHT);
        const change = Math.abs(building.height - previousHeight) / baseline;
        if (change >= 0.2) return;
        const scale = Math.random() < 0.5 ? 0.75 : 1.25;
        building.height = clamp(building.height * scale, MIN_BUILDING_HEIGHT, MAX_BUILDING_HEIGHT);
      }

      function shiftRightPlacement(buildings, leftIndex, currentRight) {
        const maxIndex = buildings.length - 1;
        let candidate = currentRight < maxIndex ? currentRight + 1 : currentRight - 1;
        if (candidate <= leftIndex + 4) {
          candidate = clamp(leftIndex + 5, 0, maxIndex);
        }
        return clamp(candidate, 0, maxIndex);
      }

      function attemptGorillaPlacement(variance) {
        const maxAttempts = 6;
        let finalBuildings = null;
        let finalResult = null;
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
          const forceVariation = attempt === maxAttempts;
          const candidateBuildings = generateBuildings(variance);
          const result = placeGorillas(candidateBuildings, lastPlacement, forceVariation);
          if (!lastPlacement || result.variationSatisfied || forceVariation) {
            finalBuildings = candidateBuildings;
            finalResult = result;
            break;
          }
        }
        if (!finalResult) {
          const fallbackBuildings = generateBuildings(variance);
          finalResult = placeGorillas(fallbackBuildings, lastPlacement, true);
          finalBuildings = fallbackBuildings;
        }
        return { buildings: finalBuildings, result: finalResult };
      }

      function enforceMidObstacle(buildings, leftIndex, rightIndex) {
        if (rightIndex <= leftIndex + 1) return;
        const blockerIndex = clamp(Math.floor((leftIndex + rightIndex) / 2), 0, buildings.length - 1);
        const blocker = buildings[blockerIndex];
        const leftHeight = buildings[leftIndex].height;
        const rightHeight = buildings[rightIndex].height;
        const desiredHeight = Math.max(leftHeight, rightHeight) + 80;
        blocker.height = clamp(Math.max(blocker.height, desiredHeight), 220, 780);
      }

      function updateHUD() {
        scoreP1.textContent = `P1-${state.scores[1]}(${state.aces[1]})`;
        scoreP2.textContent = `P2-${state.scores[2]}(${state.aces[2]})`;
        if (settings.counterfire && state.roundActive) {
          if (pendingCounterfireShots[1] && pendingCounterfireShots[2]) {
            turnIndicator.textContent = 'Counterfire in flight';
          } else {
            turnIndicator.textContent = `Player ${counterfireActiveEntry}'s Counterfire`;
          }
        } else {
          turnIndicator.textContent = state.roundActive ? `Player ${state.currentPlayer}'s Turn` : 'Round Over';
        }
        hudWind.textContent = `Wind: ${state.wind.toFixed(1)}`;
        const angle = state.wind === 0 ? 0 : (state.wind > 0 ? 0 : 180);
        const strength = Math.min(Math.abs(state.wind) / windLevels.high, 1);
        windArrow.style.transform = `rotate(${angle}deg) scale(${0.8 + strength * 0.5})`;
        windArrow.style.color = state.wind === 0 ? 'var(--muted)' : (state.wind > 0 ? 'var(--accent)' : '#60f0ff');
        lastShotText.textContent = `P1: ${lastShot[1].angle}° @ ${lastShot[1].velocity} | P2: ${lastShot[2].angle}° @ ${lastShot[2].velocity}`;
      }

      function setInputsFromLast() {
        const info = lastShot[state.currentPlayer];
        angleInput.value = info.angle;
        angleSlider.value = info.angle;
        velocityInput.value = info.velocity;
        velocitySlider.value = info.velocity;
        if (settings.counterfire) {
          syncCounterfireInputsFromLast();
          refreshCounterfireUI();
        }
      }

      function updateModeDependentControls() {
        const nonClassicMode = settings.gameMode !== 'classic';
        const aiControlsLocked = nonClassicMode || settings.opponentType !== 'ai';
        aiDifficultySelect.disabled = aiControlsLocked;
        aiDifficultySelect.style.opacity = aiControlsLocked ? '0.6' : '1';

        const opponentLocked = !isClassicMode();
        opponentSelect.disabled = opponentLocked;
        opponentSelect.style.opacity = opponentLocked ? '0.6' : '1';

        const counterfireAllowed = settings.gameMode !== 'demo';
        if (!counterfireAllowed && settings.counterfire) {
          settings.counterfire = false;
          counterfireToggle.checked = false;
          resetCounterfireEntry();
        }
        counterfireToggle.disabled = !counterfireAllowed;
        counterfireToggle.style.opacity = counterfireAllowed ? '1' : '0.6';
      }

      function isClassicMode() {
        return settings.gameMode === 'classic';
      }

      function handleGameModeChange(mode) {
        if (!mode || settings.gameMode === mode) return;
        settings.gameMode = mode;
        if (mode !== 'classic') {
          settings.opponentType = 'ai';
          opponentSelect.value = 'ai';
        }
        aiPlan.shots = [];
        updateModeDependentControls();
        refreshCounterfireUI();
        regenerateRound(true);
      }

      function launchBanana(player, angleDeg, velocity) {
        if (!state.gorillas[player - 1]) return;
        const shooter = state.gorillas[player - 1];
        const rad = angleDeg * Math.PI / 180;
        const vx = Math.cos(rad) * velocity * velocityScale * shooter.facing;
        const vy = -Math.sin(rad) * velocity * velocityScale;
        const now = performance.now();
        const speed = Math.hypot(vx, vy);
        const spin = Math.sign(vx || 1) * clamp(2 + (speed / 1400) * 2.2, 2, 7);
        const banana = {
          x: shooter.x + (gorillaSize.width / 2 + bananaRadius + 4) * shooter.facing,
          y: shooter.y - gorillaSize.height - bananaRadius * 2,
          vx,
          vy,
          elapsed: 0,
          owner: player,
          ignoreSelfUntil: now + 180,
          rotation: 0,
          spin
        };
        state.bananas.push(banana);
        state.inFlight = true;
        state.explosion = null;
        state.shotsTakenThisRound += 1;
        state.playerShotsThisRound[player] += 1;
        lastShot[player] = { angle: Math.round(angleDeg), velocity: Math.round(velocity) };
        updateHUD();
        setMessage(`Player ${player} launched a banana!`);
        playSound('whoosh');
      }

      function fireShot(angleDeg, velocity) {
        if (state.inFlight || !state.roundActive) return;
        launchBanana(state.currentPlayer, angleDeg, velocity);
      }

      function readCounterfireShot(player) {
        const cfg = counterfirePanels[player];
        const angle = clamp(Number(cfg.angleInput.value) || 0, 0, 180);
        const velocity = clamp(Number(cfg.velocityInput.value) || 5, 5, 100);
        cfg.angleInput.value = angle;
        cfg.angleSlider.value = angle;
        cfg.velocityInput.value = velocity;
        cfg.velocitySlider.value = velocity;
        return { angle, velocity };
      }

      function handleCounterfireThrow(player) {
        if (!settings.counterfire || !state.roundActive) return;
        if (pendingCounterfireShots[player]) return;
        const shot = readCounterfireShot(player);
        pendingCounterfireShots[player] = shot;
        lastShot[player] = { angle: Math.round(shot.angle), velocity: Math.round(shot.velocity) };
        counterfireActiveEntry = player === 1 ? 2 : 1;
        refreshCounterfireUI();
        if (settings.opponentType === 'ai' && player === 1) {
          const aiShot = computeOptimalShot(state.gorillas[1], state.gorillas[0]);
          pendingCounterfireShots[2] = { angle: aiShot.angle, velocity: aiShot.velocity };
          lastShot[2] = { angle: Math.round(aiShot.angle), velocity: Math.round(aiShot.velocity) };
        }
        if (pendingCounterfireShots[1] && pendingCounterfireShots[2]) {
          launchCounterfireShots();
          return;
        }
        const waitingFor = settings.opponentType === 'ai' ? 'AI' : `Player ${counterfireActiveEntry}`;
        setMessage(`Player ${player} ready. Waiting for ${waitingFor}.`);
      }

      function launchCounterfireShots() {
        [1, 2].forEach(player => {
          const shot = pendingCounterfireShots[player];
          if (shot) {
            launchBanana(player, shot.angle, shot.velocity);
          }
        });
        setMessage('Counterfire volley launched!');
        setControlsEnabled(false);
        setSettingsEnabled(false);
        refreshCounterfireUI();
      }

      function handleControlSubmit(e) {
        e.preventDefault();
        if (settings.counterfire) return;
        if (settings.opponentType === 'ai' && state.currentPlayer === 2) return;
        const angle = clamp(Number(angleInput.value) || 0, 0, 180);
        const velocity = clamp(Number(velocityInput.value) || 5, 5, 100);
        angleInput.value = angle;
        angleSlider.value = angle;
        velocityInput.value = velocity;
        velocitySlider.value = velocity;
        fireShot(angle, velocity);
      }

      function handleNewRound() {
        regenerateRound(true);
      }

      function handleResetScores() {
        state.scores[1] = 0;
        state.scores[2] = 0;
        state.aces[1] = 0;
        state.aces[2] = 0;
        setSettingsEnabled(true);
        regenerateRound(true);
      }

      function checkCollisions(banana) {
        const radius = bananaRadius;
        for (let i = 0; i < state.gorillas.length; i++) {
          if (banana.owner === i + 1 && banana.ignoreSelfUntil && performance.now() < banana.ignoreSelfUntil) {
            continue;
          }
          const g = state.gorillas[i];
          const gx = g.x - gorillaSize.width / 2;
          const gy = g.y - gorillaSize.height;
          if (banana.x + radius > gx && banana.x - radius < gx + gorillaSize.width &&
            banana.y + radius > gy && banana.y - radius < gy + gorillaSize.height) {
            return { type: 'gorilla', target: i + 1, position: { x: banana.x, y: banana.y } };
          }
        }
        for (const b of state.buildings) {
          const topY = world.groundY - b.height;
          if (banana.x + radius > b.x && banana.x - radius < b.x + b.width &&
            banana.y + radius > topY && banana.y - radius < world.groundY) {
            return { type: 'building', position: { x: banana.x, y: banana.y } };
          }
        }
        return null;
      }

      function earlyMiss(banana) {
        if (!state.roundActive) return false;
        const shooterIndex = banana.owner - 1;
        const targetIndex = shooterIndex === 0 ? 1 : 0;
        const target = state.gorillas[targetIndex];
        const direction = Math.sign(target.x - state.gorillas[shooterIndex].x) || 1;
        const margin = 180;

        const passedTarget = direction > 0 ? banana.x > target.x + margin : banana.x < target.x - margin;
        if (!passedTarget) return false;

        if (state.wind === 0 || Math.sign(state.wind) === Math.sign(banana.vx)) return true;
        const timeToReverse = Math.abs(banana.vx / state.wind);
        if (timeToReverse > 3) return true;
        const projectedX = banana.x + banana.vx * timeToReverse + 0.5 * state.wind * timeToReverse * timeToReverse;
        const farPast = direction > 0 ? projectedX > target.x + 400 : projectedX < target.x - 400;
        return farPast;
      }

      function resolveBanana(index, result, banana) {
        state.bananas.splice(index, 1);
        state.inFlight = state.bananas.length > 0;
        state.explosion = { x: result.position.x, y: result.position.y, started: performance.now() };
        const shooter = banana.owner;
        if (result.type === 'gorilla') {
          if (volleyDeadTargets.has(result.target)) {
            if (state.bananas.length === 0) finalizeVolley();
            return;
          }
          volleyDeadTargets.add(result.target);
          const scorer = result.target === shooter ? (shooter === 1 ? 2 : 1) : shooter;
          state.scores[scorer] += 1;
          const firstShotForShooter = state.playerShotsThisRound[shooter] === 1;
          if (firstShotForShooter) {
            state.aces[scorer] += 1;
          }
          resolutionBuffer.push({ type: 'gorilla', scorer, shooter, target: result.target });
          playSound('bigExplosion');
        } else {
          resolutionBuffer.push({ type: 'miss', shooter });
          playSound('explosion');
        }
        if (state.bananas.length === 0) {
          finalizeVolley();
        }
      }

      function finalizeVolley() {
        const gorillaHits = resolutionBuffer.filter(r => r.type === 'gorilla');
        if (gorillaHits.length > 0) {
          state.roundActive = false;
          const uniqueTargets = new Set(gorillaHits.map(r => r.target));
          const bannerText = uniqueTargets.size === 2
            ? 'Double KO! Both players score.'
            : `Player ${gorillaHits[gorillaHits.length - 1].scorer} wins the round!`;
          setMessage(`${bannerText} New round in 3s...`);
          showRoundBanner(`${bannerText} New round in 3s...`);
          setSettingsEnabled(true);
          setControlsEnabled(false);
          scheduleNextRound();
        } else {
          state.currentPlayer = state.currentPlayer === 1 ? 2 : 1;
          setInputsFromLast();
          setSettingsEnabled(true);
          setControlsEnabled(true);
          if (!settings.counterfire) {
            maybeTriggerAI();
          }
          resetCounterfireEntry();
          setMessage('Missed. Next turn!');
        }
        resolutionBuffer = [];
        volleyDeadTargets.clear();
        updateHUD();
      }

      function scheduleNextRound() {
        if (nextRoundTimeout) {
          clearTimeout(nextRoundTimeout);
        }
        if (nextRoundInterval) {
          clearInterval(nextRoundInterval);
        }
        nextRoundCountdown = 3;
        const updateBanner = () => {
          showRoundBanner(`New round in ${nextRoundCountdown}s`);
          setMessage(`New round in ${nextRoundCountdown}s`);
        };
        updateBanner();
        nextRoundInterval = setInterval(() => {
          nextRoundCountdown -= 1;
          if (nextRoundCountdown <= 0) {
            clearInterval(nextRoundInterval);
            nextRoundInterval = null;
          } else {
            updateBanner();
          }
        }, 1000);
        nextRoundTimeout = setTimeout(() => {
          nextRoundTimeout = null;
          hideRoundBanner();
          regenerateRound(true);
        }, 3000);
      }

      function advancePhysicsStep(obj, dt) {
        obj.vx += state.wind * dt;
        obj.vy += state.gravity * dt;
        obj.x += obj.vx * dt;
        obj.y += obj.vy * dt;
        if (obj.spin) obj.rotation = (obj.rotation || 0) + obj.spin * dt;
        obj.elapsed += dt;
      }

      function step(timestamp) {
        let frameTime = (timestamp - lastFrame) / 1000;
        lastFrame = timestamp;

        // Cap frame time to prevent "spiral of death" or huge jumps
        if (frameTime > 0.25) frameTime = 0.25;

        accumulator += frameTime;

        while (accumulator >= SIM_DT) {
          if (state.bananas.length > 0) {
            for (let i = state.bananas.length - 1; i >= 0; i--) {
              const b = state.bananas[i];
              advancePhysicsStep(b, SIM_DT);
              const collision = checkCollisions(b);
              if (collision) {
                resolveBanana(i, { ...collision }, b);
                continue;
              }
              if (earlyMiss(b) || shouldEndAsMiss(b)) {
                resolveBanana(i, { type: 'miss', position: { x: b.x, y: b.y } }, b);
              }
            }
          }
          accumulator -= SIM_DT;
        }

        render();
        requestAnimationFrame(step);
      }

      function shouldEndAsMiss(banana) {
        if (banana.elapsed > maxFlightSeconds) return true;
        const outWide = banana.x < -280 || banana.x > world.width + 280;
        const belowGround = banana.y > world.groundY + 160;
        if (outWide && belowGround) return true;
        return false;
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const scale = Math.min(canvas.width / world.width, canvas.height / world.height);
        const offsetX = (canvas.width - world.width * scale) / 2;
        const offsetY = Math.max(canvas.height - world.height * scale, 0);

        const toScreen = (x, y) => ({
          x: x * scale + offsetX,
          y: y * scale + offsetY
        });

        // Sky gradient
        const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
        sky.addColorStop(0, '#0b1c3d');
        sky.addColorStop(0.6, '#0a1224');
        sky.addColorStop(1, '#070c16');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Stars
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        for (let i = 0; i < 35; i++) {
          const x = (i * 67 + state.wind * 2) % canvas.width;
          const y = (i * 31) % (canvas.height * 0.4);
          ctx.fillRect(x, y, 2, 2);
        }

        // Buildings
        state.buildings.forEach(b => {
          const top = toScreen(b.x, world.groundY - b.height);
          const bottom = toScreen(b.x + b.width, world.groundY);
          ctx.fillStyle = b.color;
          ctx.fillRect(top.x, top.y, (bottom.x - top.x), (bottom.y - top.y));
          ctx.fillStyle = 'rgba(255,255,255,0.05)';
          const windowW = 12 * scale;
          const windowH = 14 * scale;
          for (let x = top.x + 10 * scale; x < bottom.x - windowW; x += 26 * scale) {
            for (let y = top.y + 16 * scale; y < bottom.y - windowH; y += 26 * scale) {
              if (Math.random() > 0.7) continue;
              ctx.fillRect(x, y, windowW, windowH);
            }
          }
        });

        // Gorillas
        state.gorillas.forEach((g, idx) => {
          const pos = toScreen(g.x - gorillaSize.width / 2, g.y - gorillaSize.height);
          const w = gorillaSize.width * scale;
          const h = gorillaSize.height * scale;
          const sprite = idx === 0 ? gorillaSprites.p1 : gorillaSprites.p2;
          drawGorillaImage(ctx, sprite, pos.x, pos.y, w, h, g.facing);
        });

        // Bananas
        state.bananas.forEach(b => {
          const pos = toScreen(b.x, b.y);
          drawBanana(ctx, pos.x, pos.y, scale * bananaRadius, b.rotation || 0);
        });

        // Explosion
        if (state.explosion) {
          const elapsed = performance.now() - state.explosion.started;
          if (elapsed < explosionDuration) {
            const t = elapsed / explosionDuration;
            const pos = toScreen(state.explosion.x, state.explosion.y);
            const r = (40 + 40 * t) * scale;
            const grd = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, r);
            grd.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            grd.addColorStop(0.4, 'rgba(255, 180, 40, 0.8)');
            grd.addColorStop(1, 'rgba(255, 92, 0, 0)');
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Ground line
        const groundScreen = toScreen(0, world.groundY);
        ctx.fillStyle = '#0a172e';
        ctx.fillRect(0, groundScreen.y, canvas.width, canvas.height - groundScreen.y);
      }

      function drawGorillaImage(ctx, img, x, y, w, h, facing) {
        ctx.save();
        ctx.translate(x + w / 2, y + h / 2);
        ctx.scale(facing, 1);
        ctx.drawImage(img, -w / 2, -h / 2, w, h);
        ctx.restore();
      }

      function drawBanana(ctx, x, y, r, rotation) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        const len = r * 2.9;
        const width = r * 1.15;
        ctx.beginPath();
        ctx.moveTo(-len * 0.55, -width * 0.25);
        ctx.quadraticCurveTo(-len * 0.2, -width * 0.9, len * 0.15, -width * 0.75);
        ctx.quadraticCurveTo(len * 0.72, -width * 0.55, len * 0.7, -width * 0.05);
        ctx.quadraticCurveTo(len * 0.74, width * 0.45, len * 0.25, width * 0.6);
        ctx.quadraticCurveTo(-len * 0.1, width * 0.9, -len * 0.52, width * 0.25);
        ctx.quadraticCurveTo(-len * 0.68, -width * 0.05, -len * 0.55, -width * 0.25);
        ctx.closePath();
        const grad = ctx.createLinearGradient(-len * 0.6, 0, len * 0.8, 0);
        grad.addColorStop(0, '#fde047');
        grad.addColorStop(0.5, '#fbbf24');
        grad.addColorStop(1, '#f59e0b');
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.lineWidth = r * 0.16;
        ctx.strokeStyle = '#b45309';
        ctx.stroke();

        // Speckles
        ctx.fillStyle = 'rgba(146,64,14,0.6)';
        const spots = 8;
        for (let i = 0; i < spots; i++) {
          const sx = -len * 0.4 + (len * 0.8 * i) / spots;
          const sy = (Math.sin(i * 1.2) * width) / 3;
          ctx.beginPath();
          ctx.ellipse(sx, sy, r * 0.08, r * 0.12, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        // Stem
        ctx.fillStyle = '#78350f';
        ctx.beginPath();
        ctx.roundRect(len * 0.65, -width * 0.2, r * 0.4, width * 0.4, r * 0.12);
        ctx.fill();
        ctx.restore();
      }

      function createSoundPlayer() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();

        const makeNoiseBuffer = (duration) => {
          const length = Math.floor(ctx.sampleRate * duration);
          const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < length; i++) {
            data[i] = Math.random() * 2 - 1;
          }
          return buffer;
        };

        function playWhoosh() {
          const now = ctx.currentTime;
          const duration = 0.35;
          const noise = ctx.createBufferSource();
          noise.buffer = makeNoiseBuffer(duration);
          const band = ctx.createBiquadFilter();
          band.type = 'bandpass';
          band.frequency.setValueAtTime(950, now);
          band.frequency.exponentialRampToValueAtTime(480, now + duration);
          band.Q.value = 1.1;
          const gain = ctx.createGain();
          gain.gain.setValueAtTime(0.16, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
          noise.connect(band).connect(gain).connect(ctx.destination);
          noise.start(now);
          noise.stop(now + duration + 0.05);
        }

        function playExplosion(kind = 'regular') {
          const now = ctx.currentTime;
          const isBig = kind === 'big';
          const duration = isBig ? 1.1 : 0.7;

          const noise = ctx.createBufferSource();
          noise.buffer = makeNoiseBuffer(duration);
          const filter = ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(isBig ? 2600 : 2000, now);
          filter.frequency.exponentialRampToValueAtTime(isBig ? 900 : 750, now + duration * 0.5);
          const gain = ctx.createGain();
          gain.gain.setValueAtTime(isBig ? 0.85 : 0.55, now);
          gain.gain.exponentialRampToValueAtTime(0.0008, now + duration);

          // High crack layer
          const crack = ctx.createBufferSource();
          crack.buffer = makeNoiseBuffer(0.18);
          const crackFilter = ctx.createBiquadFilter();
          crackFilter.type = 'highpass';
          crackFilter.frequency.setValueAtTime(2800, now);
          const crackGain = ctx.createGain();
          crackGain.gain.setValueAtTime(isBig ? 0.28 : 0.2, now);
          crackGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);

          // Low boom sine for big hits
          let boomOsc = null;
          let boomGain = null;
          if (isBig) {
            boomOsc = ctx.createOscillator();
            boomOsc.type = 'sine';
            boomOsc.frequency.setValueAtTime(70, now);
            boomOsc.frequency.exponentialRampToValueAtTime(45, now + 0.5);
            boomGain = ctx.createGain();
            boomGain.gain.setValueAtTime(0.5, now);
            boomGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
            boomOsc.connect(boomGain).connect(ctx.destination);
          }

          noise.connect(filter).connect(gain).connect(ctx.destination);
          crack.connect(crackFilter).connect(crackGain).connect(ctx.destination);

          noise.start(now);
          noise.stop(now + duration + 0.1);
          crack.start(now);
          crack.stop(now + 0.25);
          if (boomOsc && boomGain) {
            boomOsc.start(now);
            boomOsc.stop(now + 0.65);
          }
        }

        return {
          play: (name) => {
            if (name === 'whoosh') playWhoosh();
            if (name === 'explosion') playExplosion('regular');
            if (name === 'bigExplosion') playExplosion('big');
          }
        };
      }

      function createGorillaSprites() {
        const makeSprite = (accentPrimary, accentSecondary) => {
          const canvas = document.createElement('canvas');
          canvas.width = 360;
          canvas.height = 440;
          const c = canvas.getContext('2d');
          c.translate(canvas.width / 2, canvas.height - 32);

          // Shadow
          const shadowGrad = c.createRadialGradient(0, 8, 8, 0, 8, 120);
          shadowGrad.addColorStop(0, 'rgba(0,0,0,0.38)');
          shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
          c.fillStyle = shadowGrad;
          c.beginPath();
          c.ellipse(0, 10, 120, 22, 0, 0, Math.PI * 2);
          c.fill();

          // Torso
          const torsoGrad = c.createLinearGradient(0, -280, 0, 40);
          torsoGrad.addColorStop(0, '#3f3f45');
          torsoGrad.addColorStop(0.35, '#2f2f34');
          torsoGrad.addColorStop(1, '#1b1b1f');
          c.fillStyle = torsoGrad;
          c.beginPath();
          c.moveTo(-90, -250);
          c.bezierCurveTo(-140, -190, -150, -40, -120, 40);
          c.bezierCurveTo(-94, 110, 94, 110, 120, 40);
          c.bezierCurveTo(150, -40, 140, -190, 90, -250);
          c.closePath();
          c.fill();

          // Chest highlight
          const chestGrad = c.createRadialGradient(0, -120, 20, 0, -120, 120);
          chestGrad.addColorStop(0, 'rgba(206,200,180,0.65)');
          chestGrad.addColorStop(0.4, 'rgba(206,200,180,0.38)');
          chestGrad.addColorStop(1, 'rgba(206,200,180,0)');
          c.fillStyle = chestGrad;
          c.beginPath();
          c.ellipse(0, -120, 70, 90, 0, 0, Math.PI * 2);
          c.fill();

          // Legs
          c.fillStyle = '#19191d';
          c.beginPath();
          c.roundRect(-82, -42, 62, 128, 24);
          c.roundRect(20, -42, 62, 128, 24);
          c.fill();

          // Feet
          c.fillStyle = '#3a3630';
          c.beginPath();
          c.ellipse(-52, 88, 44, 18, 0, 0, Math.PI * 2);
          c.ellipse(52, 88, 44, 18, 0, 0, Math.PI * 2);
          c.fill();

          // Arms
          c.fillStyle = '#25252b';
          c.beginPath();
          c.moveTo(-150, -120);
          c.bezierCurveTo(-118, -90, -40, -20, -20, 22);
          c.bezierCurveTo(-8, 48, -26, 80, -50, 88);
          c.bezierCurveTo(-92, 70, -150, 22, -170, -48);
          c.closePath();
          c.fill();
          c.beginPath();
          c.moveTo(150, -120);
          c.bezierCurveTo(118, -90, 40, -20, 20, 22);
          c.bezierCurveTo(8, 48, 26, 80, 50, 88);
          c.bezierCurveTo(92, 70, 150, 22, 170, -48);
          c.closePath();
          c.fill();

          // Accent wraps
          c.fillStyle = accentPrimary;
          c.fillRect(-38, 24, 16, 18);
          c.fillRect(22, 24, 16, 18);
          c.fillStyle = accentSecondary;
          c.fillRect(-38, 40, 16, 10);
          c.fillRect(22, 40, 16, 10);

          // Head
          const headGrad = c.createLinearGradient(0, -320, 0, -200);
          headGrad.addColorStop(0, '#46494f');
          headGrad.addColorStop(1, '#2a2d33');
          c.fillStyle = headGrad;
          c.beginPath();
          c.ellipse(0, -250, 64, 58, 0, 0, Math.PI * 2);
          c.fill();

          // Brow band
          c.fillStyle = '#1a1b1f';
          c.beginPath();
          c.ellipse(0, -268, 70, 18, 0, 0, Math.PI * 2);
          c.fill();

          // Face
          const faceGrad = c.createLinearGradient(0, -240, 0, -200);
          faceGrad.addColorStop(0, '#d5d5d0');
          faceGrad.addColorStop(1, '#9c9c96');
          c.fillStyle = faceGrad;
          c.beginPath();
          c.moveTo(-42, -220);
          c.bezierCurveTo(-30, -240, -20, -244, 0, -244);
          c.bezierCurveTo(20, -244, 30, -240, 42, -220);
          c.bezierCurveTo(44, -198, 36, -176, 0, -176);
          c.bezierCurveTo(-36, -176, -44, -198, -42, -220);
          c.closePath();
          c.fill();

          // Eyes
          c.fillStyle = '#0f0f12';
          c.beginPath();
          c.ellipse(-18, -230, 9, 9, 0, 0, Math.PI * 2);
          c.ellipse(18, -230, 9, 9, 0, 0, Math.PI * 2);
          c.fill();
          c.fillStyle = 'white';
          c.beginPath();
          c.ellipse(-15, -232, 3, 3, 0, 0, Math.PI * 2);
          c.ellipse(21, -232, 3, 3, 0, 0, Math.PI * 2);
          c.fill();

          // Nose and mouth
          c.strokeStyle = '#0f0f12';
          c.lineWidth = 3;
          c.lineCap = 'round';
          c.beginPath();
          c.moveTo(-8, -210);
          c.quadraticCurveTo(0, -206, 8, -210);
          c.stroke();
          c.beginPath();
          c.moveTo(-18, -198);
          c.quadraticCurveTo(0, -192, 18, -198);
          c.stroke();

          // Fur edge texture
          c.strokeStyle = 'rgba(255,255,255,0.08)';
          c.lineWidth = 2;
          for (let i = -80; i <= 80; i += 16) {
            c.beginPath();
            c.moveTo(i, -220);
            c.lineTo(i + rand(-6, 6), -200 + rand(-6, 6));
            c.stroke();
          }

          const img = new Image();
          img.src = canvas.toDataURL('image/png');
          return img;
        };

        return {
          p1: makeSprite('#fbbf24', '#f97316'),
          p2: makeSprite('#60a5fa', '#22d3ee')
        };
      }

      function maybeTriggerAI() {
        if (settings.counterfire || settings.opponentType !== 'ai' || !state.roundActive || state.currentPlayer !== 2) return;
        setSettingsEnabled(false);
        setControlsEnabled(false);
        if (aiTimeout) clearTimeout(aiTimeout);
        aiTimeout = setTimeout(() => {
          if (aiPlan.shots.length === 0) {
            aiPlan.shots = buildAiPlan(state.gorillas[1], state.gorillas[0]);
          }
          const shot = aiPlan.shots.shift() || computeOptimalShot(state.gorillas[1], state.gorillas[0]);
          fireShot(shot.angle, shot.velocity);
          aiTimeout = null;
        }, 500);
      }

      controlForm.addEventListener('submit', handleControlSubmit);
      newRoundBtn.addEventListener('click', handleNewRound);
      resetScoresBtn.addEventListener('click', handleResetScores);
      angleInput.addEventListener('input', () => angleSlider.value = angleInput.value);
      angleSlider.addEventListener('input', () => angleInput.value = angleSlider.value);
      velocityInput.addEventListener('input', () => velocitySlider.value = velocityInput.value);
      velocitySlider.addEventListener('input', () => velocityInput.value = velocitySlider.value);
      cfAngleInput1.addEventListener('input', () => cfAngleSlider1.value = cfAngleInput1.value);
      cfAngleSlider1.addEventListener('input', () => cfAngleInput1.value = cfAngleSlider1.value);
      cfVelocityInput1.addEventListener('input', () => cfVelocitySlider1.value = cfVelocityInput1.value);
      cfVelocitySlider1.addEventListener('input', () => cfVelocityInput1.value = cfVelocitySlider1.value);
      cfAngleInput2.addEventListener('input', () => cfAngleSlider2.value = cfAngleInput2.value);
      cfAngleSlider2.addEventListener('input', () => cfAngleInput2.value = cfAngleSlider2.value);
      cfVelocityInput2.addEventListener('input', () => cfVelocitySlider2.value = cfVelocityInput2.value);
      cfVelocitySlider2.addEventListener('input', () => cfVelocityInput2.value = cfVelocitySlider2.value);
      counterfirePanels[1].button.addEventListener('click', () => handleCounterfireThrow(1));
      counterfirePanels[2].button.addEventListener('click', () => handleCounterfireThrow(2));
      counterfireToggle.addEventListener('change', () => {
        if (settings.gameMode === 'demo') {
          counterfireToggle.checked = false;
          return;
        }
        settings.counterfire = counterfireToggle.checked;
        resetCounterfireEntry();
      });
      document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'r') handleNewRound();
        if (e.key !== 'Enter') return;
        const activeEl = document.activeElement;
        if (activeEl && activeEl.tagName === 'BUTTON') return;
        e.preventDefault();
        if (settings.counterfire) {
          const panelOwner = activeEl && typeof activeEl.closest === 'function'
            ? activeEl.closest('.player-panel')
            : null;
          let player = panelOwner ? Number(panelOwner.dataset.player) : counterfireActiveEntry;
          if (Number.isNaN(player)) player = counterfireActiveEntry;
          handleCounterfireThrow(player);
        } else {
          handleControlSubmit(e);
        }
      });

      opponentSelect.addEventListener('change', () => {
        settings.opponentType = opponentSelect.value;
        aiPlan.shots = [];
        if (state.shotsTakenThisRound === 0) {
          setMessage('Opponent updated.');
        } else {
          regenerateRound(true);
        }
        updateModeDependentControls();
        refreshCounterfireUI();
        maybeTriggerAI();
      });
      gameModeRadios.forEach(radio => {
        radio.addEventListener('change', (event) => {
          handleGameModeChange(event.target.value);
        });
      });
      aiDifficultySelect.addEventListener('change', () => {
        settings.aiDifficulty = aiDifficultySelect.value;
        if (state.shotsTakenThisRound === 0) {
          setMessage('AI difficulty updated.');
        } else {
          regenerateRound(true);
        }
      });
      gravitySelect.addEventListener('change', () => {
        settings.gravityLevel = gravitySelect.value;
        if (state.shotsTakenThisRound === 0) {
          setMessage('Gravity updated.');
        } else {
          regenerateRound(true);
        }
      });
      windSelect.addEventListener('change', () => {
        settings.windMode = windSelect.value;
        if (state.shotsTakenThisRound === 0) {
          const windBound = windLevels[settings.windMode];
          state.wind = windBound === 0 ? 0 : rand(-windBound, windBound);
          updateHUD();
          setMessage('Wind updated.');
        } else {
          regenerateRound(true);
        }
      });
      varianceSelect.addEventListener('change', () => {
        settings.skylineVariance = varianceSelect.value;
        regenerateRound();
      });
      muteToggle.addEventListener('change', () => {
        setMessage(muteToggle.checked ? 'Sounds muted' : 'Sounds on');
      });

      sidebarToggle.addEventListener('click', () => {
        sidebar.classList.toggle('open');
      });
      sidebar.addEventListener('click', (e) => {
        if (e.target === sidebar && sidebar.classList.contains('open')) {
          sidebar.classList.remove('open');
        }
      });

      regenerateRound(true);
      updateModeDependentControls();
      refreshCounterfireUI();
      requestAnimationFrame(step);
    })();
  </script>
</body>

</html>
