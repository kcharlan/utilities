<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gorilla.BAS Web</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #0b1222;
      --panel-strong: #0a1329;
      --accent: #ffcc4d;
      --accent-2: #60a5fa;
      --text: #e2e8f0;
      --muted: #8ea0c5;
      --danger: #ef4444;
      --success: #10b981;
      --shadow: 0 15px 40px rgba(0, 0, 0, 0.35);
      --border: 1px solid rgba(255, 255, 255, 0.08);
      --radius: 12px;
      --font: "Futura", "Gill Sans", "Trebuchet MS", "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, rgba(96, 165, 250, 0.12), transparent 35%), radial-gradient(circle at 80% 10%, rgba(239, 68, 68, 0.18), transparent 30%), var(--bg);
      color: var(--text);
      font-family: var(--font);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header.hud {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 14px 18px;
      background: rgba(9, 12, 24, 0.88);
      border-bottom: var(--border);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .hud .title {
      font-weight: 700;
      letter-spacing: 0.04em;
      font-size: 18px;
    }

    .pill {
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      border: var(--border);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
    }

    .lives-pill {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.18), rgba(16, 185, 129, 0.05));
      border-color: rgba(16, 185, 129, 0.45);
      color: #4ade80;
      display: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .lives-pill.visible {
      display: inline-flex;
      opacity: 1;
    }

    .stats-trigger {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 13px;
      letter-spacing: 0.01em;
    }

    .wind-arrow {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transform: rotate(0deg);
      color: var(--accent);
      transition: transform 0.3s ease, color 0.3s ease;
    }

    .scoreboard {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }

    .turn-indicator {
      padding: 8px 12px;
      border-radius: 10px;
      background: linear-gradient(120deg, rgba(255, 204, 77, 0.15), rgba(96, 165, 250, 0.12));
      border: var(--border);
      color: var(--text);
      font-weight: 600;
    }

    .layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 14px;
      padding: 14px 14px 22px;
      flex: 1;
    }

    aside.sidebar {
      background: rgba(11, 18, 34, 0.9);
      border: var(--border);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      overflow: hidden;
    }

    aside.sidebar.locked {
      opacity: 0.5;
      pointer-events: none;
      filter: grayscale(0.4);
    }

    .sidebar h3 {
      margin: 0 0 8px;
      font-size: 16px;
      letter-spacing: 0.02em;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 10px;
      padding: 10px;
      border: var(--border);
    }

    .mode-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .mode-options label {
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
    }

    label {
      font-size: 13px;
      color: var(--muted);
    }

    select,
    input[type="number"],
    input[type="range"] {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: var(--font);
      transition: border-color 0.2s ease, transform 0.15s ease;
    }

    select:focus,
    input:focus {
      outline: none;
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    button {
      background: linear-gradient(120deg, #fbbf24, #f97316);
      color: #0f172a;
      border: none;
      padding: 12px 14px;
      border-radius: 10px;
      font-weight: 700;
      letter-spacing: 0.01em;
      cursor: pointer;
      box-shadow: 0 10px 25px rgba(249, 115, 22, 0.35);
      transition: transform 0.1s ease, box-shadow 0.2s ease;
      font-family: var(--font);
    }

    button:hover {
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .button-secondary {
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .game-shell {
      background: rgba(12, 17, 30, 0.92);
      border-radius: var(--radius);
      border: var(--border);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .canvas-wrap {
      position: relative;
      flex: 1;
      min-height: 420px;
      background: linear-gradient(180deg, #0b1b38 0%, #0a1222 55%, #0b0f1b 100%);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .floating-message {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(15, 23, 42, 0.8);
      border: var(--border);
      padding: 10px 14px;
      border-radius: 10px;
      color: var(--muted);
      font-size: 13px;
      backdrop-filter: blur(8px);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      padding: 14px;
      background: rgba(8, 13, 26, 0.9);
      border-top: var(--border);
    }

    .controls.disabled {
      opacity: 0.5;
      filter: grayscale(0.5);
      pointer-events: none;
    }

    .controls.controls-locked {
      opacity: 0.5;
      pointer-events: none;
      filter: grayscale(0.5);
    }

    .controls.demo-mode .counterfire-controls,
    .controls.demo-mode .counterfire-status {
      display: none;
    }

    .counterfire-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
      max-width: 600px;
      margin: 0 auto;
    }

    .hidden {
      display: none !important;
    }

    .player-panel {
      min-height: 220px;
      border: var(--border);
      border-radius: 10px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .player-panel.active {
      border-color: var(--accent);
      box-shadow: inset 0 0 0 1px rgba(255, 204, 77, 0.25);
    }

    .player-panel button {
      width: 100%;
      padding: 10px;
    }

    .counterfire-status {
      grid-column: 1 / -1;
      font-size: 13px;
      color: var(--muted);
      padding: 8px 12px;
      border-radius: 8px;
      border: var(--border);
      background: rgba(255, 255, 255, 0.02);
      max-width: 320px;
      margin: 0 auto;
      text-align: center;
    }

    .controls .field {
      height: 100%;
    }

    .input-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .control-actions {
      gap: 6px;
      padding: 4px 0 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0 auto;
      max-width: 220px;
    }

    .control-actions button {
      width: 100%;
      padding: 8px 12px;
      font-size: 13px;
    }

    .last-shot {
      color: var(--muted);
      font-size: 13px;
    }

    .last-shot.compact {
      margin-top: auto;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }

    .hud-toggle {
      margin-left: auto;
      display: none;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    @media (max-width: 980px) {
      .layout {
        grid-template-columns: 1fr;
      }

      aside.sidebar {
        position: fixed;
        inset: 0 0 0 30%;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        z-index: 20;
        max-width: 360px;
      }

      aside.sidebar.open {
        transform: translateX(0);
      }

      .hud-toggle {
        display: inline-flex;
      }
    }

    @media (max-width: 680px) {
      aside.sidebar {
        inset: 0;
      }

      header.hud {
        flex-wrap: wrap;
        gap: 10px;
      }
    }

    .round-banner {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.02em;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.55));
      color: var(--text);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .round-banner.visible {
      opacity: 1;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(5, 7, 18, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
    }

    .stats-columns {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 8px;
    }

    .stats-column {
      border: var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .stats-column h4 {
      margin: 0;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--muted);
    }

    .stats-count {
      font-size: 28px;
      font-weight: 700;
      color: var(--text);
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: var(--muted);
    }

    .stats-table {
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      padding-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
    }

    .stats-table .stats-table-row {
      display: flex;
      justify-content: space-between;
    }

    .stats-table-row.stats-table-header span {
      font-weight: 600;
      color: var(--text);
    }

    .stats-empty {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-content {
      background: rgba(8, 13, 26, 0.95);
      border: var(--border);
      border-radius: 16px;
      padding: 24px;
      width: min(420px, 90%);
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .modal-content p {
      color: var(--muted);
      margin: 0;
      line-height: 1.5;
    }

    .modal-content .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .modal-content .modal-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      justify-content: flex-end;
    }
  </style>
</head>

<body>
  <div id="app">
    <header class="hud">
      <div class="title">Gorilla.BAS Web</div>
      <div class="pill" aria-live="polite">
        <span class="wind-arrow" id="windArrow">‚ûú</span>
        <span id="windText">Wind: 0</span>
      </div>
      <div class="pill scoreboard" aria-live="polite">
        <span id="scoreP1">P1-0(0)</span>
        <span>‚Äî</span>
        <span id="scoreP2">P2-0(0)</span>
      </div>
      <div class="pill lives-pill" id="livesCounter" hidden>ü¶ç x5</div>
      <button class="button-secondary stats-trigger" id="statsButton" type="button">Stats</button>
      <div class="turn-indicator" id="turnIndicator">Player 1's Turn</div>
      <button class="hud-toggle" id="sidebarToggle" aria-label="Toggle settings sidebar">Settings</button>
    </header>

    <div class="layout">
      <aside class="sidebar" id="sidebar" aria-label="Settings">
        <h3>Settings</h3>
        <div class="field">
          <label>Game Mode</label>
          <div class="mode-options" role="radiogroup" aria-label="Game mode">
            <label><input type="radio" name="gameMode" value="classic" checked> Classic</label>
            <label><input type="radio" name="gameMode" value="demo"> Demo</label>
            <label><input type="radio" name="gameMode" value="arcade"> Arcade</label>
          </div>
        </div>
        <div class="field">
          <label for="opponentSelect">Opponent Type</label>
          <select id="opponentSelect">
            <option value="ai">Vs AI</option>
            <option value="local">Local 2-Player</option>
          </select>
        </div>
        <div class="field">
          <label><input type="checkbox" id="counterfireToggle"> Counterfire</label>
        </div>
        <div class="field">
          <label for="aiDifficulty">AI Difficulty</label>
          <select id="aiDifficulty">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        <div class="field">
          <label for="gravitySelect">Gravity</label>
          <select id="gravitySelect">
            <option value="low">Low</option>
            <option value="normal" selected>Normal</option>
            <option value="high">High</option>
          </select>
        </div>
        <div class="field">
          <label for="windSelect">Wind</label>
          <select id="windSelect">
            <option value="off">Off</option>
            <option value="low" selected>Low</option>
            <option value="high">High</option>
          </select>
        </div>
        <div class="field">
          <label><input type="checkbox" id="muteToggle"> Mute Sounds</label>
        </div>
        <div class="field">
          <label for="varianceSelect">Skyline Variance</label>
          <select id="varianceSelect">
            <option value="low">Low</option>
            <option value="normal" selected>Normal</option>
            <option value="high">High</option>
          </select>
        </div>
        <div class="field">
          <label>Help</label>
          <button type="button" class="button-secondary" id="helpButton">Open Help</button>
        </div>
      </aside>

      <section class="game-shell">
        <div class="canvas-wrap">
          <canvas id="gameCanvas" aria-label="Gorilla battlefield"></canvas>
          <div class="floating-message" id="messageBox">Generate a skyline and start throwing!</div>
          <div class="round-banner" id="roundBanner" aria-live="assertive"></div>
        </div>
        <form class="controls" id="controlForm">
          <div class="counterfire-controls" id="counterfireControls">
            <div class="player-panel" id="counterfirePlayer1" data-player="1">
              <label for="cfAngleInput1">Player 1 Angle</label>
              <div class="input-row">
                <input type="number" id="cfAngleInput1" min="0" max="180" value="60" aria-label="Player 1 angle">
                <input type="range" id="cfAngleSlider1" min="0" max="180" value="60" aria-label="Player 1 angle slider">
              </div>
              <label for="cfVelocityInput1">Player 1 Velocity</label>
              <div class="input-row">
                <input type="number" id="cfVelocityInput1" min="5" max="100" value="55" aria-label="Player 1 velocity">
                <input type="range" id="cfVelocitySlider1" min="5" max="100" value="55"
                  aria-label="Player 1 velocity slider">
              </div>
              <button type="button" class="counterfireThrow" data-player="1">Player 1 Throw</button>
              <div class="last-shot compact" id="lastShotP1">P1: 60¬∞ @ 55</div>
            </div>
            <div class="player-panel" id="counterfirePlayer2" data-player="2">
              <label for="cfAngleInput2">Player 2 Angle</label>
              <div class="input-row">
                <input type="number" id="cfAngleInput2" min="0" max="180" value="60" aria-label="Player 2 angle">
                <input type="range" id="cfAngleSlider2" min="0" max="180" value="60" aria-label="Player 2 angle slider">
              </div>
              <label for="cfVelocityInput2">Player 2 Velocity</label>
              <div class="input-row">
                <input type="number" id="cfVelocityInput2" min="5" max="100" value="55" aria-label="Player 2 velocity">
                <input type="range" id="cfVelocitySlider2" min="5" max="100" value="55"
                  aria-label="Player 2 velocity slider">
              </div>
              <button type="button" class="counterfireThrow" data-player="2">Player 2 Throw</button>
              <div class="last-shot compact" id="lastShotP2">P2: 60¬∞ @ 55</div>
            </div>
            <div class="counterfire-status" id="counterfireStatus">Waiting for Player 1</div>
          </div>
          <div class="field control-actions">
            <button type="button" class="button-secondary" id="newRoundBtn">New Round</button>
            <button type="button" class="button-secondary" id="resetScoresBtn">Reset Scores</button>
          </div>
        </form>
      </section>
    </div>
  </div>
  <div class="modal-overlay" id="helpModal">
    <div class="modal-content">
      <h3>Game Help</h3>
      <p><strong>Controls:</strong> Set <strong>Angle (0-180¬∞)</strong> and <strong>Velocity</strong>. Press
        <strong>Throw</strong> or <strong>Enter</strong> to fire. Shots can fly off-screen and return.
      </p>
      <p><strong>Modes:</strong>
        <br>‚Ä¢ <strong>Classic:</strong> Infinite rounds. Standard turn-based play.
        <br>‚Ä¢ <strong>Arcade:</strong> Survival mode. You have 5 lives against the AI.
        <br>‚Ä¢ <strong>Counterfire:</strong> (Setting) Both players fire simultaneously in a volley.
      </p>
      <p><strong>Keys:</strong> <strong>R</strong> to restart round.</p>
      <button type="button" class="button-secondary modal-close" id="helpModalClose">Close</button>
    </div>
  </div>

  <div class="modal-overlay" id="statsModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Session Stats</h3>
        <button type="button" class="button-secondary modal-close" id="statsModalClose">Close</button>
      </div>
      <p>Track kills, aces, and how many shots each player needed in this session.</p>
      <div class="stats-columns">
        <div class="stats-column" id="statsPlayer1"></div>
        <div class="stats-column" id="statsPlayer2"></div>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="arcadeOverlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Arcade Over</h3>
        <button type="button" class="button-secondary modal-close" id="arcadeCloseBtn">Close</button>
      </div>
      <p id="arcadeOverlayMessage">You've run out of lives. Stats shown below‚Äîstart a new arcade run or switch modes.
      </p>
      <div class="stats-columns">
        <div class="stats-column" id="arcadeStatsPlayer1"></div>
        <div class="stats-column" id="arcadeStatsPlayer2"></div>
      </div>
      <div class="modal-actions">
        <button type="button" class="button-secondary" id="arcadeRestartBtn">Start New Arcade Run</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const hudWind = document.getElementById('windText');
      const windArrow = document.getElementById('windArrow');
      const scoreP1 = document.getElementById('scoreP1');
      const scoreP2 = document.getElementById('scoreP2');
      const turnIndicator = document.getElementById('turnIndicator');
      const messageBox = document.getElementById('messageBox');
      const roundBanner = document.getElementById('roundBanner');

      const lastShotP1 = document.getElementById('lastShotP1');
      const lastShotP2 = document.getElementById('lastShotP2');
      const controlForm = document.getElementById('controlForm');
      const newRoundBtn = document.getElementById('newRoundBtn');
      const resetScoresBtn = document.getElementById('resetScoresBtn');
      const sidebar = document.getElementById('sidebar');
      const sidebarToggle = document.getElementById('sidebarToggle');

      const opponentSelect = document.getElementById('opponentSelect');
      const counterfireToggle = document.getElementById('counterfireToggle');
      const counterfireControls = document.getElementById('counterfireControls');
      const counterfireStatus = document.getElementById('counterfireStatus');
      const cfAngleInput1 = document.getElementById('cfAngleInput1');
      const cfAngleSlider1 = document.getElementById('cfAngleSlider1');
      const cfVelocityInput1 = document.getElementById('cfVelocityInput1');
      const cfVelocitySlider1 = document.getElementById('cfVelocitySlider1');
      const cfAngleInput2 = document.getElementById('cfAngleInput2');
      const cfAngleSlider2 = document.getElementById('cfAngleSlider2');
      const cfVelocityInput2 = document.getElementById('cfVelocityInput2');
      const cfVelocitySlider2 = document.getElementById('cfVelocitySlider2');
      const cfPlayerPanel1 = document.getElementById('counterfirePlayer1');
      const cfPlayerPanel2 = document.getElementById('counterfirePlayer2');
      const aiDifficultySelect = document.getElementById('aiDifficulty');
      const gravitySelect = document.getElementById('gravitySelect');
      const windSelect = document.getElementById('windSelect');
      const varianceSelect = document.getElementById('varianceSelect');
      const gameModeRadios = document.querySelectorAll('input[name="gameMode"]');
      const helpButton = document.getElementById('helpButton');
      const helpModal = document.getElementById('helpModal');
      const helpModalClose = document.getElementById('helpModalClose');
      const statsButton = document.getElementById('statsButton');
      const statsModal = document.getElementById('statsModal');
      const statsModalClose = document.getElementById('statsModalClose');
      const statsPlayer1 = document.getElementById('statsPlayer1');
      const statsPlayer2 = document.getElementById('statsPlayer2');
      const livesCounter = document.getElementById('livesCounter');
      const arcadeOverlay = document.getElementById('arcadeOverlay');
      const arcadeStatsPlayer1 = document.getElementById('arcadeStatsPlayer1');
      const arcadeStatsPlayer2 = document.getElementById('arcadeStatsPlayer2');
      const arcadeRestartBtn = document.getElementById('arcadeRestartBtn');
      const arcadeCloseBtn = document.getElementById('arcadeCloseBtn');
      const counterfirePanels = {
        1: {
          angleInput: cfAngleInput1,
          angleSlider: cfAngleSlider1,
          velocityInput: cfVelocityInput1,
          velocitySlider: cfVelocitySlider1,
          panel: cfPlayerPanel1,
          button: cfPlayerPanel1.querySelector('.counterfireThrow[data-player="1"]')
        },
        2: {
          angleInput: cfAngleInput2,
          angleSlider: cfAngleSlider2,
          velocityInput: cfVelocityInput2,
          velocitySlider: cfVelocitySlider2,
          panel: cfPlayerPanel2,
          button: cfPlayerPanel2.querySelector('.counterfireThrow[data-player="2"]')
        }
      };

      const world = {
        width: 2200,
        height: 1200,
        groundY: 1100
      };

      const MIN_BUILDING_HEIGHT = 180;
      const MAX_BUILDING_HEIGHT = 780;
      const MID_OBSTACLE_EXTRA = 96;
      const MID_OBSTACLE_MIN = 240;
      const SIMPLE_MID_OBSTACLE_EXTRA = 64;
      const SIMPLE_MID_OBSTACLE_MIN = 230;
      const SIMPLE_MID_OBSTACLE_MAX = 430;
      const GORILLA_NEIGHBOR_CAP = 110;
      const GORILLA_EDGE_MARGIN = 220;
      const GORILLA_ZONE_BAND = 320;
      const MIN_BUILDING_WIDTH = 140;
      const MAX_BUILDING_WIDTH = 220;
      const BUILDING_GAP_MIN = -12;
      const BUILDING_GAP_MAX = 14;

      const gorillaSize = { width: 90, height: 105 };
      const bananaRadius = 14; // Slightly larger banana for better readability
      const explosionDuration = 650;
      const maxFlightSeconds = 12;
      const PROJECTILE_MISS_OUT_X_MARGIN = 280;
      const PROJECTILE_MISS_OUT_Y_MARGIN = 160;
      const velocityScale = 11; // Converts player velocity units to world units/sec.
      const VALIDATION_REASONABLE_MIN_ANGLE = 14;
      const VALIDATION_REASONABLE_MAX_ANGLE = 86;
      const VALIDATION_REASONABLE_MAX_VELOCITY = 96;

      // FIXED TIME STEP CONSTANTS
      const SIM_DT = 0.015; // 15ms per physics tick
      let accumulator = 0;

      const settings = {
        opponentType: 'ai',
        gameMode: 'classic',
        aiDifficulty: 'medium',
        gravityLevel: 'normal',
        windMode: 'low',
        skylineVariance: 'normal',
        counterfire: false
      };

      function detectUrlGameMode() {
        const params = new URLSearchParams(window.location.search);
        if (params.has('demo') || params.get('mode') === 'demo') {
          return 'demo';
        }
        const hashMode = window.location.hash.replace(/^#/, '').toLowerCase();
        if (!hashMode) return null;
        if (hashMode === 'demo') return 'demo';
        const hashParams = new URLSearchParams(hashMode.replace(/^\?/, ''));
        if (hashParams.has('demo') || hashParams.get('mode') === 'demo') return 'demo';
        return null;
      }

      const urlMode = detectUrlGameMode();
      if (urlMode) {
        settings.gameMode = urlMode;
      }
      let lastManualMode = settings.gameMode !== 'demo' ? settings.gameMode : 'classic';

      const aiPlans = { 1: [], 2: [] };
      function resetAiPlans() {
        aiPlans[1] = [];
        aiPlans[2] = [];
      }

      const lastShot = {
        1: { angle: 60, velocity: 55 },
        2: { angle: 60, velocity: 55 }
      };

      const state = {
        currentPlayer: 1,
        scores: { 1: 0, 2: 0 },
        aces: { 1: 0, 2: 0 },
        playerShotsThisRound: { 1: 0, 2: 0 },
        roundShots: { 1: 0, 2: 0 },
        buildings: [],
        gorillas: [],
        wind: 0,
        gravity: 70,
        bananas: [],
        inFlight: false,
        explosion: null,
        roundActive: true,
        shotsTakenThisRound: 0
      };
      state.stats = null;
      state.lives = 5;

      function resetStatsData() {
        state.stats = {
          1: { kills: 0, aces: 0, killsByShotCount: {} },
          2: { kills: 0, aces: 0, killsByShotCount: {} }
        };
      }
      resetStatsData();

      let lastPlacement = null;

      const pendingCounterfireShots = { 1: null, 2: null };
      let counterfireActiveEntry = 1;
      let resolutionBuffer = [];
      let volleyDeadTargets = new Set();
      let statsModalOpen = false;
      let interactionSnapshot = null;
      let arcadeOverlayVisible = false;
      let arcadeDifficultyLocked = false;

      let lastFrame = performance.now();

      const gravityLevels = { low: 55, normal: 70, high: 90 };
      const windLevels = { off: 0, low: 15, high: 30 };
      const varianceLevels = { low: 0.12, normal: 0.28, high: 0.48 };

      opponentSelect.value = settings.opponentType;
      gameModeRadios.forEach(radio => {
        radio.checked = radio.value === settings.gameMode;
      });
      counterfireToggle.checked = settings.counterfire;
      aiDifficultySelect.value = settings.aiDifficulty;

      const gorillaSprites = createGorillaSprites();
      const soundPlayer = createSoundPlayer();

      function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = Math.max(420, canvas.clientHeight || 520);
      }

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      let nextRoundTimeout = null;
      let nextRoundInterval = null;
      let nextRoundCountdown = 0;
      let nextRoundScheduled = false;
      let aiTimeout = null;

      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function isProjectileOutOfMissBounds(x, y) {
        const outWide = x < -PROJECTILE_MISS_OUT_X_MARGIN || x > world.width + PROJECTILE_MISS_OUT_X_MARGIN;
        const belowGround = y > world.groundY + PROJECTILE_MISS_OUT_Y_MARGIN;
        return outWide && belowGround;
      }

      function simulateShot(angleDeg, velocity, shooter, target, buildings = state.buildings, wind = state.wind, gravity = state.gravity) {
        const rad = angleDeg * Math.PI / 180;
        const vx0 = Math.cos(rad) * velocity * velocityScale * shooter.facing;
        const vy0 = -Math.sin(rad) * velocity * velocityScale;
        const banana = {
          x: shooter.x + (gorillaSize.width / 2 + bananaRadius + 4) * shooter.facing,
          y: shooter.y - gorillaSize.height - bananaRadius * 2,
          vx: vx0,
          vy: vy0,
          elapsed: 0
        };

        const targetRect = {
          x: target.x - gorillaSize.width / 2,
          y: target.y - gorillaSize.height,
          w: gorillaSize.width,
          h: gorillaSize.height
        };

        for (let t = 0; t < maxFlightSeconds; t += SIM_DT) {
          // Inline physics to allow custom wind
          banana.vx += wind * SIM_DT;
          banana.vy += gravity * SIM_DT;
          banana.x += banana.vx * SIM_DT;
          banana.y += banana.vy * SIM_DT;

          const x = banana.x;
          const y = banana.y;

          if (x + bananaRadius > targetRect.x && x - bananaRadius < targetRect.x + targetRect.w &&
            y + bananaRadius > targetRect.y && y - bananaRadius < targetRect.y + targetRect.h) {
            return { hit: true, angle: angleDeg, velocity };
          }

          for (const b of buildings) {
            const topY = world.groundY - b.height;
            if (x + bananaRadius > b.x && x - bananaRadius < b.x + b.width &&
              y + bananaRadius > topY && y - bananaRadius < world.groundY) {
              return { hit: false, reason: 'building' };
            }
          }

          if (isProjectileOutOfMissBounds(x, y)) {
            return { hit: false, reason: 'out' };
          }
        }
        return { hit: false, reason: 'timeout' };
      }

      function computeOptimalShot(shooter, target, buildings = state.buildings, wind = state.wind, gravity = state.gravity) {
        let best = null;
        let bestMiss = Infinity;
        for (let velocity = 20; velocity <= 100; velocity += 2) {
          for (let angle = 10; angle <= 88; angle += 1) {
            const res = simulateShot(angle, velocity, shooter, target, buildings, wind, gravity);
            if (res.hit) return { angle, velocity };

            // Refined miss metric:
            // If we hit a building, the distance is not useful (we are blocked).
            // We should heavily penalize building hits to prefer clear shots or misses that go over.
            let miss = Infinity;

            if (res.reason === 'building') {
              miss = 100000; // Heavy penalty
            } else {
              // Calculate miss based on where the projectile actually landed or exited
              // We only care about X distance at target height
              // Re-simulate briefly to find X at target Y if possible? 
              // For performance, just use the simple metric but only if NOT a building hit.
              miss = Math.abs(target.x - (shooter.x + Math.cos(angle * Math.PI / 180) * velocity));
            }

            if (miss < bestMiss) {
              bestMiss = miss;
              best = { angle, velocity };
            }
          }
        }
        return best || { angle: 45, velocity: 60 };
      }

      function buildAiPlan(shooter, target) {
        const solution = computeOptimalShot(shooter, target);
        const difficulty = settings.aiDifficulty;
        let missCount = 0;
        if (difficulty === 'hard') {
          missCount = Math.floor(Math.random() * 3); // 0-2
        } else if (difficulty === 'medium') {
          missCount = Math.floor(Math.random() * 6); // 0-5
        } else {
          missCount = Math.floor(Math.random() * 8) + 3; // 3-10
        }

        const shots = [];
        if (missCount === 0) {
          shots.push(solution);
          return shots;
        }

        const offsetSign = Math.random() < 0.5 ? -1 : 1;
        let startOffset;
        if (difficulty === 'hard') {
          startOffset = rand(1, 6) * offsetSign;
        } else if (difficulty === 'medium') {
          startOffset = rand(3, 10) * offsetSign;
        } else {
          startOffset = rand(6, 15) * offsetSign;
        }

        for (let i = 0; i < missCount; i++) {
          const factor = (missCount - i) / missCount; // strictly decreases toward 0
          const offset = startOffset * factor;
          shots.push({
            angle: clamp(solution.angle + offset * 0.2, 10, 88),
            velocity: clamp(solution.velocity + offset, 5, 100)
          });
        }

        shots.push(solution);
        return shots;
      }

      function planAiShotFor(player) {
        const shooterIndex = player - 1;
        const targetIndex = shooterIndex === 0 ? 1 : 0;
        const shooter = state.gorillas[shooterIndex];
        const target = state.gorillas[targetIndex];
        if (!shooter || !target) return null;
        if (aiPlans[player].length === 0) {
          aiPlans[player] = buildAiPlan(shooter, target);
        }
        const shotList = aiPlans[player];
        return shotList.shift() || computeOptimalShot(shooter, target);
      }

      function setMessage(text) {
        messageBox.textContent = text;
      }

      function playSound(name) {
        if (muteToggle.checked) return;
        soundPlayer.play(name);
      }

      function setControlsEnabled(enabled) {
        controlForm.classList.toggle('disabled', !enabled);
        controlForm.querySelectorAll('input, button').forEach(el => {
          el.disabled = !enabled;
        });
      }

      function setSettingsEnabled(enabled) {
        sidebar.classList.toggle('locked', !enabled);
        controlForm.classList.toggle('controls-locked', !enabled);
        sidebar.querySelectorAll('select, input').forEach(el => {
          el.disabled = !enabled;
        });
      }

      function snapshotInteractionState() {
        return {
          controlsEnabled: !controlForm.classList.contains('disabled'),
          settingsEnabled: !sidebar.classList.contains('locked')
        };
      }

      function restoreInteractionState(snapshot) {
        if (!snapshot) return;
        setControlsEnabled(snapshot.controlsEnabled);
        setSettingsEnabled(snapshot.settingsEnabled);
      }

      function renderStatsColumn(container, player) {
        const data = state.stats[player];
        if (!data) {
          container.innerHTML = '';
          return;
        }
        const buckets = Object.keys(data.killsByShotCount)
          .map(k => Number(k))
          .filter(num => !Number.isNaN(num))
          .sort((a, b) => a - b);
        const rows = buckets.map(value => `
          <div class="stats-table-row">
            <span>Shot #${value}</span>
            <span>${data.killsByShotCount[value]}</span>
          </div>
        `).join('');
        const tableMarkup = rows
          ? `
            <div class="stats-table">
              <div class="stats-table-row stats-table-header">
                <span>Shot #</span>
                <span>Kills</span>
              </div>
              ${rows}
            </div>
          `
          : `<div class="stats-empty">No kills recorded yet.</div>`;
        container.innerHTML = `
          <h4>Player ${player}</h4>
          <div class="stats-count">${data.kills} Kills</div>
          <div class="stats-row">
            <span>Aces</span>
            <span>${data.aces}</span>
          </div>
          ${tableMarkup}
        `;
      }

      function renderStatsPanels() {
        [statsPlayer1, statsPlayer2].forEach((el, idx) => {
          if (el) renderStatsColumn(el, idx + 1);
        });
        [arcadeStatsPlayer1, arcadeStatsPlayer2].forEach((el, idx) => {
          if (el) renderStatsColumn(el, idx + 1);
        });
      }

      function openStatsModal() {
        if (statsModalOpen || arcadeOverlayVisible) return;
        interactionSnapshot = snapshotInteractionState();
        renderStatsPanels();
        setControlsEnabled(false);
        setSettingsEnabled(false);
        statsModal.classList.add('active');
        statsModalOpen = true;
      }

      function closeStatsModal() {
        if (!statsModalOpen) return;
        statsModalOpen = false;
        statsModal.classList.remove('active');
        restoreInteractionState(interactionSnapshot);
        interactionSnapshot = null;
      }

      function recordKillStats(scorer, shotCount, isAce) {
        const stats = state.stats[scorer];
        if (!stats) return;
        stats.kills += 1;
        if (isAce) {
          stats.aces += 1;
        }
        const bucket = shotCount > 0 ? shotCount : 0;
        stats.killsByShotCount[bucket] = (stats.killsByShotCount[bucket] || 0) + 1;
      }

      function syncCounterfireInputsFromLast() {
        for (const player of [1, 2]) {
          const info = lastShot[player];
          const cfg = counterfirePanels[player];
          cfg.angleInput.value = info.angle;
          cfg.angleSlider.value = info.angle;
          cfg.velocityInput.value = info.velocity;
          cfg.velocitySlider.value = info.velocity;
        }
      }

      function linkInputPair(input, slider) {
        input.addEventListener('input', () => slider.value = input.value);
        slider.addEventListener('input', () => input.value = slider.value);
      }

      function updateCounterfirePanelStates() {
        const bothPending = Boolean(pendingCounterfireShots[1] && pendingCounterfireShots[2]);
        const demoMode = settings.gameMode === 'demo';
        for (const player of [1, 2]) {
          const cfg = counterfirePanels[player];
          const isAIPlayer = settings.opponentType === 'ai' && player === 2;
          cfg.panel.hidden = isAIPlayer;
          let enabled = false;
          if (settings.counterfire) {
            const hasShot = Boolean(pendingCounterfireShots[player]);
            enabled = state.roundActive && !hasShot && !bothPending && counterfireActiveEntry === player && !isAIPlayer;
          } else {
            enabled = state.roundActive && !state.inFlight && state.currentPlayer === player && !isAIPlayer;
          }
          if (demoMode) {
            enabled = false;
          }
          const disabled = !enabled;
          cfg.angleInput.disabled = disabled;
          cfg.angleSlider.disabled = disabled;
          cfg.velocityInput.disabled = disabled;
          cfg.velocitySlider.disabled = disabled;
          cfg.button.disabled = disabled;
          cfg.panel.classList.toggle('active', enabled);
        }
        if (!settings.counterfire) {
          counterfireStatus.textContent = state.roundActive ? `Player ${state.currentPlayer}'s controls` : 'Round paused';
        } else if (bothPending) {
          counterfireStatus.textContent = 'Counterfire volley launched!';
        } else {
          counterfireStatus.textContent = `Waiting for Player ${counterfireActiveEntry}`;
        }
      }

      function refreshCounterfireUI() {
        const enabled = settings.counterfire;
        controlForm.classList.toggle('counterfire-active', enabled);
        updateCounterfirePanelStates();
      }

      function resetCounterfireEntry() {
        pendingCounterfireShots[1] = null;
        pendingCounterfireShots[2] = null;
        counterfireActiveEntry = settings.counterfire ? 1 : state.currentPlayer;
        volleyDeadTargets.clear();
        resolutionBuffer = [];
        syncCounterfireInputsFromLast();
        refreshCounterfireUI();
      }

      function showRoundBanner(text) {
        roundBanner.textContent = text;
        roundBanner.classList.add('visible');
      }

      function hideRoundBanner() {
        roundBanner.classList.remove('visible');
        roundBanner.textContent = '';
      }

      function clearPendingNextRound() {
        nextRoundScheduled = false;
        if (nextRoundTimeout) {
          clearTimeout(nextRoundTimeout);
          nextRoundTimeout = null;
        }
        if (nextRoundInterval) {
          clearInterval(nextRoundInterval);
          nextRoundInterval = null;
        }
      }

      function createLevelSpec(variance, previousPlacement, simpleMode, gravity = state.gravity, wind = state.wind) {
        const windFactor = clamp(Math.abs(wind) / Math.max(1, windLevels.high), 0, 1);
        const gravityFactor = clamp((gravity - gravityLevels.normal) / Math.max(1, gravityLevels.high - gravityLevels.normal), 0, 1);
        const challengeFactor = clamp(windFactor * 0.75 + gravityFactor * 0.35, 0, 1);
        const leftZone = {
          xMin: GORILLA_EDGE_MARGIN,
          xMax: GORILLA_EDGE_MARGIN + GORILLA_ZONE_BAND
        };
        const rightZone = {
          xMin: world.width - GORILLA_EDGE_MARGIN - GORILLA_ZONE_BAND,
          xMax: world.width - GORILLA_EDGE_MARGIN
        };

        const zoneInset = simpleMode ? 0 : GORILLA_ZONE_BAND * 0.25 * challengeFactor;
        const leftMin = leftZone.xMin + zoneInset;
        const leftMax = leftZone.xMax;
        const rightMin = rightZone.xMin;
        const rightMax = rightZone.xMax - zoneInset;
        let leftX = rand(leftMin, leftMax);
        let rightX = rand(rightMin, rightMax);
        const minDx = 1080;
        const maxDx = simpleMode ? 1350 : clamp(1480 - challengeFactor * 260, 1140, 1480);
        let dx = Math.abs(rightX - leftX);
        if (dx > maxDx) {
          let remaining = dx - maxDx;
          const moveLeft = Math.min(leftMax - leftX, remaining / 2);
          leftX += moveLeft;
          remaining -= moveLeft;
          const moveRight = Math.min(rightX - rightMin, remaining);
          rightX -= moveRight;
          remaining -= moveRight;
          if (remaining > 0) {
            leftX = Math.min(leftMax, leftX + remaining);
          }
        } else if (dx < minDx) {
          let remaining = minDx - dx;
          const moveLeft = Math.min(leftX - leftMin, remaining / 2);
          leftX -= moveLeft;
          remaining -= moveLeft;
          const moveRight = Math.min(rightMax - rightX, remaining);
          rightX += moveRight;
          remaining -= moveRight;
          if (remaining > 0) {
            rightX = Math.min(rightMax, rightX + remaining);
          }
        }
        const maxHeight = simpleMode
          ? world.height * 0.35
          : clamp(620 - challengeFactor * 110, MIN_BUILDING_HEIGHT, 620);
        const baseHeight = 280;

        let leftHeight = clamp(
          baseHeight * (1 + rand(-variance, variance)) + rand(60, 220),
          MIN_BUILDING_HEIGHT,
          maxHeight
        );
        let rightHeight = clamp(
          baseHeight * (1 + rand(-variance, variance)) + rand(60, 220),
          MIN_BUILDING_HEIGHT,
          maxHeight
        );

        const previousLeftHeight = previousPlacement && previousPlacement.left
          ? previousPlacement.left.height
          : null;
        const previousRightHeight = previousPlacement && previousPlacement.right
          ? previousPlacement.right.height
          : null;

        leftHeight = ensureHeightVariation(leftHeight, previousLeftHeight, maxHeight);
        rightHeight = ensureHeightVariation(rightHeight, previousRightHeight, maxHeight);

        dx = Math.abs(rightX - leftX);
        const dy = Math.abs(leftHeight - rightHeight);
        const tallerHeight = Math.max(leftHeight, rightHeight);
        const span = Math.floor(dx / 180);
        const spanBoost = clamp(
          (span - 5) * (simpleMode ? 4 : 6) * (1 - challengeFactor * 0.4),
          0,
          simpleMode ? 30 : 50
        );
        const obstacleExtra = (simpleMode ? SIMPLE_MID_OBSTACLE_EXTRA : MID_OBSTACLE_EXTRA) * (1 - challengeFactor * 0.35);
        const obstacleMaxHeight = simpleMode
          ? SIMPLE_MID_OBSTACLE_MAX
          : clamp(700 - challengeFactor * 90, 560, 700);
        const minObstacleHeight = clamp(
          tallerHeight + obstacleExtra + spanBoost,
          simpleMode ? SIMPLE_MID_OBSTACLE_MIN : MID_OBSTACLE_MIN,
          obstacleMaxHeight
        );
        const maxObstacleHeight = clamp(
          minObstacleHeight + (simpleMode ? 70 : 110),
          minObstacleHeight,
          obstacleMaxHeight
        );

        const clearanceZones = [
          {
            x: leftX - 200,
            width: 400,
            maxHeight: leftHeight + GORILLA_NEIGHBOR_CAP,
            priority: 'high'
          },
          {
            x: rightX - 200,
            width: 400,
            maxHeight: rightHeight + GORILLA_NEIGHBOR_CAP,
            priority: 'high'
          }
        ];

        return {
          leftZone,
          rightZone,
          leftX,
          rightX,
          leftHeight,
          rightHeight,
          horizontalSeparation: dx,
          heightDifference: dy,
          minObstacleHeight,
          maxObstacleHeight,
          fillerMaxHeight: simpleMode ? world.height * 0.35 : clamp(maxHeight + 40, MIN_BUILDING_HEIGHT, 620),
          clearanceZones,
          variance,
          simpleMode
        };
      }

      function ensureHeightVariation(proposedHeight, previousHeight, maxHeight = MAX_BUILDING_HEIGHT) {
        if (!Number.isFinite(previousHeight)) return proposedHeight;

        const baseline = Math.max(previousHeight, MIN_BUILDING_HEIGHT);
        const change = Math.abs(proposedHeight - previousHeight) / baseline;
        if (change >= 0.2) return proposedHeight;

        const scale = Math.random() < 0.5 ? 0.75 : 1.25;
        return clamp(proposedHeight * scale, MIN_BUILDING_HEIGHT, maxHeight);
      }

      function planBuildingZones(spec) {
        const leftBuildingWidth = rand(MIN_BUILDING_WIDTH, MAX_BUILDING_WIDTH);
        const rightBuildingWidth = rand(MIN_BUILDING_WIDTH, MAX_BUILDING_WIDTH);
        const obstacleBuildingWidth = rand(120, 190);

        const leftBuildingX = clamp(spec.leftX - leftBuildingWidth / 2, 0, world.width - leftBuildingWidth);
        const minRightX = leftBuildingX + leftBuildingWidth + 320;
        const maxRightX = world.width - rightBuildingWidth;
        let rightBuildingX = spec.rightX - rightBuildingWidth / 2;
        if (minRightX <= maxRightX) {
          rightBuildingX = clamp(rightBuildingX, minRightX, maxRightX);
        } else {
          rightBuildingX = maxRightX;
        }

        const midX = (spec.leftX + spec.rightX) / 2;
        const obstaclePadding = 120;
        const obstacleMinX = leftBuildingX + leftBuildingWidth + obstaclePadding;
        const obstacleMaxX = rightBuildingX - obstacleBuildingWidth - obstaclePadding;
        let obstacleBuildingX = midX - obstacleBuildingWidth / 2;
        if (obstacleMinX <= obstacleMaxX) {
          obstacleBuildingX = clamp(obstacleBuildingX, obstacleMinX, obstacleMaxX);
        } else {
          const fallbackMin = leftBuildingX + leftBuildingWidth + 24;
          const fallbackMax = rightBuildingX - obstacleBuildingWidth - 24;
          if (fallbackMin <= fallbackMax) {
            obstacleBuildingX = clamp(obstacleBuildingX, fallbackMin, fallbackMax);
          } else {
            obstacleBuildingX = clamp(obstacleBuildingX, 0, world.width - obstacleBuildingWidth);
          }
        }

        const keyBuildings = [
          {
            type: 'gorilla-platform',
            side: 'left',
            x: leftBuildingX,
            width: leftBuildingWidth,
            height: spec.leftHeight,
            fixed: true,
            gorillaX: spec.leftX
          },
          {
            type: 'obstacle',
            x: obstacleBuildingX,
            width: obstacleBuildingWidth,
            minHeight: spec.minObstacleHeight,
            maxHeight: spec.maxObstacleHeight,
            fixed: false
          },
          {
            type: 'gorilla-platform',
            side: 'right',
            x: rightBuildingX,
            width: rightBuildingWidth,
            height: spec.rightHeight,
            fixed: true,
            gorillaX: spec.rightX
          }
        ].sort((a, b) => a.x - b.x);

        const allZones = [];
        allZones.push(...createFillerZones(0, keyBuildings[0].x, spec));
        allZones.push(keyBuildings[0]);

        for (let i = 1; i < keyBuildings.length; i++) {
          const prevEnd = keyBuildings[i - 1].x + keyBuildings[i - 1].width;
          const nextStart = keyBuildings[i].x;
          allZones.push(...createFillerZones(prevEnd, nextStart, spec));
          allZones.push(keyBuildings[i]);
        }

        const lastKey = keyBuildings[keyBuildings.length - 1];
        allZones.push(...createFillerZones(lastKey.x + lastKey.width, world.width, spec));
        return allZones;
      }

      function createFillerZones(startX, endX, spec) {
        const zones = [];
        let x = clamp(startX, 0, world.width);
        const stopX = clamp(endX, 0, world.width);
        if (x >= stopX) return zones;

        while (x < stopX) {
          const remainingWidth = stopX - x;
          if (remainingWidth < 80) {
            break;
          }

          let width = rand(MIN_BUILDING_WIDTH, MAX_BUILDING_WIDTH);
          if (x + width > stopX) {
            width = remainingWidth;
          }

          zones.push(createFillerZone(x, width, spec));
          if (x + width >= stopX) {
            break;
          }

          x += width + rand(BUILDING_GAP_MIN, BUILDING_GAP_MAX);
        }

        return zones;
      }

      function createFillerZone(x, width, spec) {
        let maxHeight = spec.simpleMode ? world.height * 0.35 : spec.fillerMaxHeight;
        const minHeight = MIN_BUILDING_HEIGHT;
        const zoneEnd = x + width;

        for (const clearance of spec.clearanceZones) {
          if (zoneEnd > clearance.x && x < clearance.x + clearance.width) {
            if (clearance.priority === 'high') {
              maxHeight = Math.min(maxHeight, clearance.maxHeight);
            }
          }
        }

        return {
          type: 'filler',
          x,
          width,
          minHeight,
          maxHeight: Math.max(minHeight, maxHeight),
          fixed: false
        };
      }

      function constructBuildings(zones, spec) {
        const orderedZones = [...zones].sort((a, b) => a.x - b.x);
        const buildings = [];
        const gorillaMetadata = { left: null, right: null };

        for (const zone of orderedZones) {
          const building = {
            x: zone.x,
            width: zone.width,
            height: 0,
            color: `hsl(${rand(200, 230)}, ${rand(28, 46)}%, ${rand(25, 40)}%)`,
            windows: []
          };

          if (zone.type === 'gorilla-platform') {
            building.height = zone.height;
            const gorillaX = clamp(
              zone.gorillaX,
              zone.x + gorillaSize.width / 2 + 4,
              zone.x + zone.width - gorillaSize.width / 2 - 4
            );
            gorillaMetadata[zone.side] = {
              x: gorillaX,
              y: world.groundY - zone.height,
              buildingIndex: buildings.length,
              facing: zone.side === 'left' ? 1 : -1
            };
          } else if (zone.type === 'obstacle') {
            const heightRange = Math.max(0, zone.maxHeight - zone.minHeight);
            building.height = clamp(
              zone.minHeight + rand(0, Math.min(heightRange, 90)),
              zone.minHeight,
              zone.maxHeight
            );
          } else {
            building.height = clamp(
              280 * (1 + rand(-spec.variance, spec.variance)) + rand(60, 220),
              zone.minHeight,
              zone.maxHeight
            );
          }

          buildings.push(building);
        }

        return {
          buildings,
          gorillas: [gorillaMetadata.left, gorillaMetadata.right]
        };
      }

      function generateLevelConstraintBased(variance, previousPlacement, simpleMode, gravity = state.gravity, wind = state.wind) {
        const spec = createLevelSpec(variance, previousPlacement, simpleMode, gravity, wind);
        const zones = planBuildingZones(spec);
        const { buildings, gorillas } = constructBuildings(zones, spec);
        if (!gorillas[0] || !gorillas[1]) {
          throw new Error('Constraint generation invariant failed: missing gorilla placement.');
        }

        buildings.forEach((building) => {
          building.windows = buildWindowsForBuilding(building);
        });

        const leftBuilding = buildings[gorillas[0].buildingIndex];
        const rightBuilding = buildings[gorillas[1].buildingIndex];
        const actualDx = Math.abs(gorillas[1].x - gorillas[0].x);
        const actualDy = Math.abs(leftBuilding.height - rightBuilding.height);
        const result = {
          gorillas,
          delta: {
            dx: actualDx,
            dy: actualDy
          },
          variationSatisfied: true,
          leftPlacement: {
            x: gorillas[0].x,
            y: gorillas[0].y,
            height: leftBuilding.height
          },
          rightPlacement: {
            x: gorillas[1].x,
            y: gorillas[1].y,
            height: rightBuilding.height
          }
        };

        return {
          ok: true,
          buildings,
          result,
          reason: 'constraint-based-generation'
        };
      }

      function regenerateRound(resetTurn = false, options = {}) {
        const { force = false } = options;
        if (nextRoundScheduled && !force) {
          return;
        }
        clearPendingNextRound();
        if (aiTimeout) {
          clearTimeout(aiTimeout);
          aiTimeout = null;
        }
        resetAiPlans();
        const variance = varianceLevels[settings.skylineVariance];
        const roundGravity = gravityLevels[settings.gravityLevel];
        const windBound = windLevels[settings.windMode];
        const roundWind = windBound === 0 ? 0 : rand(-windBound, windBound);
        const placementAttempt = generateLevelConstraintBased(variance, lastPlacement, false, roundGravity, roundWind);
        const layout = {
          buildings: placementAttempt.buildings,
          result: placementAttempt.result
        };

        state.buildings = layout.buildings;
        state.gorillas = layout.result.gorillas;
        lastPlacement = {
          left: layout.result.leftPlacement,
          right: layout.result.rightPlacement,
          delta: layout.result.delta
        };
        state.gravity = roundGravity;
        state.wind = roundWind;
        state.bananas = [];
        state.explosion = null;
        state.inFlight = false;
        state.roundActive = true;
        state.shotsTakenThisRound = 0;
        state.playerShotsThisRound[1] = 0;
        state.playerShotsThisRound[2] = 0;
        state.roundShots[1] = 0;
        state.roundShots[2] = 0;
        setControlsEnabled(true);
        setSettingsEnabled(true);
        updateModeDependentControls();
        resetCounterfireEntry();
        nextRoundCountdown = 0;
        hideRoundBanner();
        if (resetTurn) state.currentPlayer = 1;
        updateHUD();
        setInputsFromLast();
        setMessage(isDemoMode() ? 'Demo mode: AI vs AI running automatically.' : 'New skyline ready. Aim carefully!');
        maybeTriggerAI();
      }

      function buildWindowsForBuilding(building) {
        const windows = [];
        const topY = world.groundY - building.height;
        const windowW = 12;
        const windowH = 14;
        for (let x = building.x + 10; x < building.x + building.width - windowW; x += 26) {
          for (let y = topY + 16; y < world.groundY - windowH; y += 26) {
            if (Math.random() > 0.7) continue;
            windows.push({ x, y, w: windowW, h: windowH });
          }
        }
        return windows;
      }

      function getSightPoint(gorilla) {
        return {
          x: gorilla.x + (gorillaSize.width / 2 + bananaRadius + 4) * gorilla.facing,
          y: gorilla.y - gorillaSize.height - bananaRadius * 2
        };
      }

      function segmentIntersectsRect(start, end, rect) {
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        let t0 = 0;
        let t1 = 1;

        const clip = (p, q) => {
          if (p === 0) return q >= 0;
          const r = q / p;
          if (p < 0) {
            if (r > t1) return false;
            if (r > t0) t0 = r;
          } else {
            if (r < t0) return false;
            if (r < t1) t1 = r;
          }
          return true;
        };

        if (!clip(-dx, start.x - rect.left)) return false;
        if (!clip(dx, rect.right - start.x)) return false;
        if (!clip(-dy, start.y - rect.top)) return false;
        if (!clip(dy, rect.bottom - start.y)) return false;
        return t1 >= t0;
      }

      function hasDirectLineOfSight(buildings, p1, p2) {
        const start = getSightPoint(p1);
        const end = getSightPoint(p2);
        const excludedIndices = new Set([p1.buildingIndex, p2.buildingIndex]);

        for (let i = 0; i < buildings.length; i++) {
          if (excludedIndices.has(i)) continue;
          const b = buildings[i];
          const rect = {
            left: b.x,
            right: b.x + b.width,
            top: world.groundY - b.height,
            bottom: world.groundY
          };
          if (segmentIntersectsRect(start, end, rect)) {
            return false;
          }
        }
        return true;
      }

      function validateLevel(buildings, p1, p2, gravity = state.gravity, wind = state.wind) {
        if (hasDirectLineOfSight(buildings, p1, p2)) {
          return false;
        }
        if (!checkDirection(p1, p2, buildings, wind, gravity)) return false;
        if (!checkDirection(p2, p1, buildings, wind, gravity)) return false;
        return true;
      }

      function isReasonableValidationShot(shot) {
        if (!shot) return false;
        const angle = Number(shot.angle);
        const velocity = Number(shot.velocity);
        if (!Number.isFinite(angle) || !Number.isFinite(velocity)) return false;
        if (angle < VALIDATION_REASONABLE_MIN_ANGLE || angle > VALIDATION_REASONABLE_MAX_ANGLE) return false;
        if (velocity > VALIDATION_REASONABLE_MAX_VELOCITY) return false;
        return true;
      }

      function findValidationShot(shooter, target, buildings, wind = 0, gravity = state.gravity) {
        const primary = computeOptimalShot(shooter, target, buildings, wind, gravity);
        const primaryCheck = simulateShot(primary.angle, primary.velocity, shooter, target, buildings, wind, gravity);
        if (primaryCheck.hit &&
          isReasonableValidationShot(primary) &&
          checkRobustness(primary, shooter, target, buildings, wind, gravity)) {
          return primary;
        }

        for (let velocity = 20; velocity <= 100; velocity += 2) {
          for (let angle = 88; angle >= 10; angle -= 1) {
            if (angle === primary.angle && velocity === primary.velocity) continue;
            const check = simulateShot(angle, velocity, shooter, target, buildings, wind, gravity);
            if (!check.hit) continue;
            const candidate = { angle, velocity };
            if (!isReasonableValidationShot(candidate)) continue;
            if (checkRobustness(candidate, shooter, target, buildings, wind, gravity)) {
              return candidate;
            }
          }
        }
        return null;
      }

      function checkDirection(shooter, target, buildings, overrideWind = 0, gravity = state.gravity) {
        const solution = findValidationShot(shooter, target, buildings, overrideWind, gravity);
        return Boolean(solution && isReasonableValidationShot(solution));
      }

      function checkRobustness(solution, shooter, target, buildings, wind = 0, gravity = state.gravity) {
        // 1. Tolerance Test: +/- 1 deg, +/- 2% power
        // If any of these "immediately collide" (hit building), fail.
        const angles = [clamp(solution.angle - 1, 1, 88), clamp(solution.angle + 1, 1, 88)];
        const vels = [solution.velocity * 0.98, solution.velocity * 1.02];

        for (const a of angles) {
          for (const v of vels) {
            const res = simulateShot(a, v, shooter, target, buildings, wind, gravity);
            if (!res.hit && res.reason === 'building') {
              return false; // Boxed in or unstable shot
            }
          }
        }

        // 2. Gap Logic: 5px clearance
        return checkClearance(solution, shooter, target, buildings, 5, wind, gravity);
      }

      function checkClearance(solution, shooter, target, buildings, minGap, wind = 0, gravity = state.gravity) {
        const rad = solution.angle * Math.PI / 180;
        let vx = Math.cos(rad) * solution.velocity * velocityScale * shooter.facing;
        let vy = -Math.sin(rad) * solution.velocity * velocityScale;
        let x = shooter.x + (gorillaSize.width / 2 + bananaRadius + 4) * shooter.facing;
        let y = shooter.y - gorillaSize.height - bananaRadius * 2;

        const safeDist = bananaRadius + minGap;
        const maxSimTime = maxFlightSeconds;

        for (let t = 0; t < maxSimTime; t += SIM_DT) {
          vx += wind * SIM_DT;
          vy += gravity * SIM_DT;
          x += vx * SIM_DT;
          y += vy * SIM_DT;

          // Check distance to buildings
          for (const b of buildings) {
            const topY = world.groundY - b.height;
            if (x + safeDist > b.x && x - safeDist < b.x + b.width &&
              y + safeDist > topY) { // Bottom check omitted
              return false;
            }
          }

          if (isProjectileOutOfMissBounds(x, y)) break;
        }
        return true;
      }

      function updateLivesDisplay() {
        if (!livesCounter) return;
        const showing = settings.gameMode === 'arcade';
        livesCounter.textContent = `ü¶ç x${state.lives}`;
        livesCounter.classList.toggle('visible', showing);
      }

      function updateHUD() {
        scoreP1.textContent = `P1-${state.scores[1]}(${state.aces[1]})`;
        scoreP2.textContent = `P2-${state.scores[2]}(${state.aces[2]})`;
        if (settings.counterfire && state.roundActive) {
          if (pendingCounterfireShots[1] && pendingCounterfireShots[2]) {
            turnIndicator.textContent = 'Counterfire in flight';
          } else {
            turnIndicator.textContent = `Player ${counterfireActiveEntry}'s Counterfire`;
          }
        } else {
          turnIndicator.textContent = state.roundActive ? `Player ${state.currentPlayer}'s Turn` : 'Round Over';
        }
        hudWind.textContent = `Wind: ${state.wind.toFixed(1)}`;
        const angle = state.wind === 0 ? 0 : (state.wind > 0 ? 0 : 180);
        const strength = Math.min(Math.abs(state.wind) / windLevels.high, 1);
        windArrow.style.transform = `rotate(${angle}deg) scale(${0.8 + strength * 0.5})`;
        windArrow.style.color = state.wind === 0 ? 'var(--muted)' : (state.wind > 0 ? 'var(--accent)' : '#60f0ff');
        lastShotP1.textContent = `P1: ${lastShot[1].angle}¬∞ @ ${lastShot[1].velocity}`;
        lastShotP2.textContent = `P2: ${lastShot[2].angle}¬∞ @ ${lastShot[2].velocity}`;
        updateLivesDisplay();
      }

      function setInputsFromLast() {
        syncCounterfireInputsFromLast();
        refreshCounterfireUI();
      }

      function showHelpModal() {
        helpModal.classList.add('active');
      }

      function hideHelpModal() {
        helpModal.classList.remove('active');
      }

      function updateModeDependentControls() {
        controlForm.classList.toggle('demo-mode', isDemoMode());
        const aiLockedByMode = isDemoMode();
        const aiLockedByArcade = settings.gameMode === 'arcade' && arcadeDifficultyLocked;
        const aiControlsLocked = settings.opponentType !== 'ai' || aiLockedByMode || aiLockedByArcade;
        aiDifficultySelect.disabled = aiControlsLocked;
        aiDifficultySelect.style.opacity = aiControlsLocked ? '0.6' : '1';

        const opponentLocked = !isClassicMode();
        opponentSelect.disabled = opponentLocked;
        opponentSelect.style.opacity = opponentLocked ? '0.6' : '1';

        const counterfireAllowed = modeAllowsCounterfire();
        counterfireToggle.disabled = !counterfireAllowed;
        counterfireToggle.style.opacity = counterfireAllowed ? '1' : '0.6';
      }

      function isClassicMode() {
        return settings.gameMode === 'classic';
      }

      function isDemoMode() {
        return settings.gameMode === 'demo';
      }

      function modeAllowsCounterfire() {
        return !isDemoMode();
      }

      function shouldAiControlPlayer(player) {
        if (!state.roundActive || state.inFlight) return false;
        if (state.currentPlayer !== player) return false;
        if (isDemoMode()) return true;
        if (settings.counterfire) return false;
        return settings.opponentType === 'ai' && player === 2;
      }

      function enforceModeConstraints() {
        if (!isClassicMode() && settings.opponentType !== 'ai') {
          settings.opponentType = 'ai';
          opponentSelect.value = 'ai';
        }
      }

      function startArcadeRun() {
        state.lives = 5;
        state.scores[1] = 0;
        state.scores[2] = 0;
        state.aces[1] = 0;
        state.aces[2] = 0;
        resetStatsData();
        state.roundShots[1] = 0;
        state.roundShots[2] = 0;
        state.playerShotsThisRound[1] = 0;
        state.playerShotsThisRound[2] = 0;
        closeArcadeOverlay();
        setMessage('Arcade run armed. 5 lives remaining.');
        updateHUD();
        arcadeDifficultyLocked = false;
      }

      function openArcadeOverlay() {
        if (arcadeOverlayVisible) return;
        closeStatsModal();
        arcadeOverlayVisible = true;
        renderStatsPanels();
        arcadeOverlay.classList.add('active');
        setMessage('Arcade Over! Lives depleted.');
        setControlsEnabled(false);
        setSettingsEnabled(false);
      }

      function closeArcadeOverlay() {
        if (!arcadeOverlayVisible) return;
        arcadeOverlayVisible = false;
        arcadeOverlay.classList.remove('active');
        setMessage('Arcade paused. Start a new run or switch modes.');
        setControlsEnabled(false);
        setSettingsEnabled(true);
      }

      function handleGameModeChange(mode) {
        if (!mode || settings.gameMode === mode) return;
        if (mode === 'demo' && settings.gameMode !== 'demo') {
          lastManualMode = settings.gameMode;
        } else if (mode !== 'demo') {
          lastManualMode = mode;
        }
        settings.gameMode = mode;
        gameModeRadios.forEach(radio => {
          radio.checked = radio.value === mode;
        });
        resetAiPlans();
        enforceModeConstraints();
        if (mode === 'arcade') {
          startArcadeRun();
        } else {
          closeArcadeOverlay();
          arcadeDifficultyLocked = false;
        }
        updateModeDependentControls();
        refreshCounterfireUI();
        regenerateRound(true, { force: true });
      }

      function launchBanana(player, angleDeg, velocity) {
        if (!state.gorillas[player - 1]) return;
        const shooter = state.gorillas[player - 1];
        const rad = angleDeg * Math.PI / 180;
        const vx = Math.cos(rad) * velocity * velocityScale * shooter.facing;
        const vy = -Math.sin(rad) * velocity * velocityScale;
        const now = performance.now();
        const speed = Math.hypot(vx, vy);
        const spin = Math.sign(vx || 1) * clamp(2 + (speed / 1400) * 2.2, 2, 7);
        const shotNumber = state.playerShotsThisRound[player] + 1;
        const banana = {
          x: shooter.x + (gorillaSize.width / 2 + bananaRadius + 4) * shooter.facing,
          y: shooter.y - gorillaSize.height - bananaRadius * 2,
          vx,
          vy,
          elapsed: 0,
          owner: player,
          ignoreSelfUntil: now + 180,
          rotation: 0,
          spin,
          shotNumber
        };
        state.bananas.push(banana);
        state.inFlight = true;
        state.explosion = null;
        state.shotsTakenThisRound += 1;
        state.playerShotsThisRound[player] = shotNumber;
        state.roundShots[player] += 1;
        lastShot[player] = { angle: Math.round(angleDeg), velocity: Math.round(velocity) };
        updateHUD();
        setMessage(`Player ${player} launched a banana!`);
        if (settings.gameMode === 'arcade' && !arcadeDifficultyLocked) {
          arcadeDifficultyLocked = true;
          setMessage('AI difficulty locked for this arcade run.');
          updateModeDependentControls();
        }
        playSound('whoosh');
      }

      function fireShot(angleDeg, velocity) {
        if (state.inFlight || !state.roundActive) return;
        launchBanana(state.currentPlayer, angleDeg, velocity);
      }

      function readPlayerShot(player) {
        const cfg = counterfirePanels[player];
        const angle = clamp(Number(cfg.angleInput.value) || 0, 0, 180);
        const velocity = clamp(Number(cfg.velocityInput.value) || 5, 5, 100);
        cfg.angleInput.value = angle;
        cfg.angleSlider.value = angle;
        cfg.velocityInput.value = velocity;
        cfg.velocitySlider.value = velocity;
        return { angle, velocity };
      }

      function handleCounterfireThrow(player) {
        if (!settings.counterfire || !state.roundActive) return;
        if (pendingCounterfireShots[player]) return;
        const shot = readPlayerShot(player);
        pendingCounterfireShots[player] = shot;
        lastShot[player] = { angle: Math.round(shot.angle), velocity: Math.round(shot.velocity) };
        counterfireActiveEntry = player === 1 ? 2 : 1;
        refreshCounterfireUI();
        if (settings.opponentType === 'ai' && player === 1) {
          const aiShot = planAiShotFor(2) || computeOptimalShot(state.gorillas[1], state.gorillas[0]);
          pendingCounterfireShots[2] = { angle: aiShot.angle, velocity: aiShot.velocity };
          lastShot[2] = { angle: Math.round(aiShot.angle), velocity: Math.round(aiShot.velocity) };
        }
        if (pendingCounterfireShots[1] && pendingCounterfireShots[2]) {
          launchCounterfireShots();
          return;
        }
        const waitingFor = settings.opponentType === 'ai' ? 'AI' : `Player ${counterfireActiveEntry}`;
        setMessage(`Player ${player} ready. Waiting for ${waitingFor}.`);
      }

      function handlePlayerThrow(player) {
        if (settings.gameMode === 'demo') return;
        if (settings.counterfire) {
          handleCounterfireThrow(player);
          return;
        }
        if (!state.roundActive || state.inFlight) return;
        if (player !== state.currentPlayer) return;
        if (settings.opponentType === 'ai' && player === 2) return;
        const shot = readPlayerShot(player);
        fireShot(shot.angle, shot.velocity);
      }

      function launchCounterfireShots() {
        [1, 2].forEach(player => {
          const shot = pendingCounterfireShots[player];
          if (shot) {
            launchBanana(player, shot.angle, shot.velocity);
          }
        });
        setMessage('Counterfire volley launched!');
        setControlsEnabled(false);
        setSettingsEnabled(false);
        refreshCounterfireUI();
      }

      function handleControlSubmit(e) {
        e.preventDefault();
        handlePlayerThrow(state.currentPlayer);
      }

      function handleNewRound() {
        if (settings.gameMode === 'arcade' && state.lives === 0) {
          startArcadeRun();
        }
        regenerateRound(true, { force: true });
      }

      function handleResetScores() {
        state.scores[1] = 0;
        state.scores[2] = 0;
        state.aces[1] = 0;
        state.aces[2] = 0;
        resetStatsData();
        closeStatsModal();
        closeArcadeOverlay();
        setSettingsEnabled(true);
        regenerateRound(true, { force: true });
      }

      function handleArcadeRestart() {
        startArcadeRun();
        regenerateRound(true, { force: true });
      }

      function checkCollisions(banana) {
        const radius = bananaRadius;
        for (let i = 0; i < state.gorillas.length; i++) {
          if (banana.owner === i + 1 && banana.ignoreSelfUntil && performance.now() < banana.ignoreSelfUntil) {
            continue;
          }
          const g = state.gorillas[i];
          const gx = g.x - gorillaSize.width / 2;
          const gy = g.y - gorillaSize.height;
          if (banana.x + radius > gx && banana.x - radius < gx + gorillaSize.width &&
            banana.y + radius > gy && banana.y - radius < gy + gorillaSize.height) {
            return { type: 'gorilla', target: i + 1, position: { x: banana.x, y: banana.y } };
          }
        }
        for (const b of state.buildings) {
          const topY = world.groundY - b.height;
          if (banana.x + radius > b.x && banana.x - radius < b.x + b.width &&
            banana.y + radius > topY && banana.y - radius < world.groundY) {
            return { type: 'building', position: { x: banana.x, y: banana.y } };
          }
        }
        return null;
      }

      function earlyMiss(banana) {
        if (!state.roundActive) return false;
        const shooterIndex = banana.owner - 1;
        const targetIndex = shooterIndex === 0 ? 1 : 0;
        const target = state.gorillas[targetIndex];
        const direction = Math.sign(target.x - state.gorillas[shooterIndex].x) || 1;
        const margin = 180;

        const passedTarget = direction > 0 ? banana.x > target.x + margin : banana.x < target.x - margin;
        if (!passedTarget) return false;

        if (state.wind === 0 || Math.sign(state.wind) === Math.sign(banana.vx)) return true;
        const timeToReverse = Math.abs(banana.vx / state.wind);
        if (timeToReverse > 3) return true;
        const projectedX = banana.x + banana.vx * timeToReverse + 0.5 * state.wind * timeToReverse * timeToReverse;
        const farPast = direction > 0 ? projectedX > target.x + 400 : projectedX < target.x - 400;
        return farPast;
      }

      function resolveBanana(index, result, banana) {
        state.bananas.splice(index, 1);
        state.inFlight = state.bananas.length > 0;
        state.explosion = { x: result.position.x, y: result.position.y, started: performance.now() };
        const shooter = banana.owner;
        if (result.type === 'gorilla') {
          const isDirectHit = result.target !== shooter;
          const firstShotForShooter = banana.shotNumber === 1;
          const scorer = isDirectHit ? shooter : (shooter === 1 ? 2 : 1);
          const shotBucket = state.roundShots[banana.owner] || banana.shotNumber;
          const alreadyDead = volleyDeadTargets.has(result.target);
          if (alreadyDead) {
            if (isDirectHit && firstShotForShooter) {
              state.aces[scorer] += 1;
            }
            if (state.bananas.length === 0) finalizeVolley();
            return;
          }
          volleyDeadTargets.add(result.target);
          state.scores[scorer] += 1;
          if (isDirectHit && firstShotForShooter) {
            state.aces[scorer] += 1;
          }
          recordKillStats(scorer, shotBucket, isDirectHit && firstShotForShooter);
          resolutionBuffer.push({ type: 'gorilla', scorer, shooter, target: result.target });
          playSound('bigExplosion');
        } else {
          resolutionBuffer.push({ type: 'miss', shooter });
          playSound('explosion');
        }
        if (state.bananas.length === 0) {
          finalizeVolley();
        }
      }

      function finalizeVolley() {
        const gorillaHits = resolutionBuffer.filter(r => r.type === 'gorilla');
        if (gorillaHits.length > 0) {
          state.roundActive = false;
          const uniqueTargets = new Set(gorillaHits.map(r => r.target));
          const bannerText = uniqueTargets.size === 2
            ? 'Double KO! Both players score.'
            : `Player ${gorillaHits[gorillaHits.length - 1].scorer} wins the round!`;
          setSettingsEnabled(true);
          updateModeDependentControls();
          setControlsEnabled(false);
          let preventedByArcade = false;
          const humanDeadThisVolley = gorillaHits.some(r => r.target === 1);
          if (settings.gameMode === 'arcade' && humanDeadThisVolley) {
            state.lives = Math.max(0, state.lives - 1);
            updateHUD();
            if (state.lives === 0) {
              preventedByArcade = true;
              openArcadeOverlay();
            } else {
              setMessage(`Player 1 down! ${state.lives} lives remaining.`);
            }
          }
          if (!preventedByArcade) {
            scheduleNextRound(bannerText);
          }
        } else {
          state.currentPlayer = state.currentPlayer === 1 ? 2 : 1;
          setInputsFromLast();
          setSettingsEnabled(true);
          setControlsEnabled(true);
          if (!settings.counterfire || isDemoMode()) {
            maybeTriggerAI();
          }
          resetCounterfireEntry();
          setMessage('Missed. Next turn!');
        }
        resolutionBuffer = [];
        volleyDeadTargets.clear();
        updateHUD();
      }

      function getNextRoundDelay() {
        return 3000;
      }

      function scheduleNextRound(bannerText) {
        clearPendingNextRound();
        const delay = getNextRoundDelay();
        nextRoundScheduled = true;
        const formatBanner = (seconds) => {
          const suffix = delay >= 1000
            ? ` New round in ${seconds}s...`
            : ' Demo mode: continuing shortly...';
          const text = `${bannerText}${suffix}`;
          showRoundBanner(text);
          setMessage(text);
        };
        if (delay >= 1000) {
          nextRoundCountdown = Math.ceil(delay / 1000);
          formatBanner(nextRoundCountdown);
          nextRoundInterval = setInterval(() => {
            nextRoundCountdown -= 1;
            if (nextRoundCountdown <= 0) {
              clearInterval(nextRoundInterval);
              nextRoundInterval = null;
              return;
            }
            formatBanner(nextRoundCountdown);
          }, 1000);
        } else {
          formatBanner(0);
        }
        nextRoundTimeout = setTimeout(() => {
          hideRoundBanner();
          regenerateRound(true, { force: true });
        }, delay);
      }

      function advancePhysicsStep(obj, dt) {
        obj.vx += state.wind * dt;
        obj.vy += state.gravity * dt;
        obj.x += obj.vx * dt;
        obj.y += obj.vy * dt;
        if (obj.spin) obj.rotation = (obj.rotation || 0) + obj.spin * dt;
        obj.elapsed += dt;
      }

      function step(timestamp) {
        let frameTime = (timestamp - lastFrame) / 1000;
        lastFrame = timestamp;

        // Cap frame time to prevent "spiral of death" or huge jumps
        if (frameTime > 0.25) frameTime = 0.25;

        accumulator += frameTime;

        while (accumulator >= SIM_DT) {
          if (state.bananas.length > 0) {
            for (let i = state.bananas.length - 1; i >= 0; i--) {
              const b = state.bananas[i];
              advancePhysicsStep(b, SIM_DT);
              const collision = checkCollisions(b);
              if (collision) {
                resolveBanana(i, { ...collision }, b);
                continue;
              }
              if (earlyMiss(b) || shouldEndAsMiss(b)) {
                resolveBanana(i, { type: 'miss', position: { x: b.x, y: b.y } }, b);
              }
            }
          }
          accumulator -= SIM_DT;
        }

        render();
        requestAnimationFrame(step);
      }

      function shouldEndAsMiss(banana) {
        if (banana.elapsed > maxFlightSeconds) return true;
        return isProjectileOutOfMissBounds(banana.x, banana.y);
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const scale = Math.min(canvas.width / world.width, canvas.height / world.height);
        const offsetX = (canvas.width - world.width * scale) / 2;
        const offsetY = Math.max(canvas.height - world.height * scale, 0);

        const toScreen = (x, y) => ({
          x: x * scale + offsetX,
          y: y * scale + offsetY
        });

        // Sky gradient
        const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
        sky.addColorStop(0, '#0b1c3d');
        sky.addColorStop(0.6, '#0a1224');
        sky.addColorStop(1, '#070c16');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Stars
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        for (let i = 0; i < 35; i++) {
          const x = (i * 67 + state.wind * 2) % canvas.width;
          const y = (i * 31) % (canvas.height * 0.4);
          ctx.fillRect(x, y, 2, 2);
        }

        // Buildings
        state.buildings.forEach(b => {
          const top = toScreen(b.x, world.groundY - b.height);
          const bottom = toScreen(b.x + b.width, world.groundY);
          ctx.fillStyle = b.color;
          ctx.fillRect(top.x, top.y, (bottom.x - top.x), (bottom.y - top.y));
          ctx.fillStyle = 'rgba(255,255,255,0.05)';
          const windows = Array.isArray(b.windows) ? b.windows : [];
          windows.forEach(win => {
            const winTop = toScreen(win.x, win.y);
            const winBottom = toScreen(win.x + win.w, win.y + win.h);
            ctx.fillRect(winTop.x, winTop.y, (winBottom.x - winTop.x), (winBottom.y - winTop.y));
          });
        });

        // Gorillas
        state.gorillas.forEach((g, idx) => {
          const pos = toScreen(g.x - gorillaSize.width / 2, g.y - gorillaSize.height);
          const w = gorillaSize.width * scale;
          const h = gorillaSize.height * scale;
          const sprite = idx === 0 ? gorillaSprites.p1 : gorillaSprites.p2;
          drawGorillaImage(ctx, sprite, pos.x, pos.y, w, h, g.facing);
        });

        // Bananas
        state.bananas.forEach(b => {
          const pos = toScreen(b.x, b.y);
          drawBanana(ctx, pos.x, pos.y, scale * bananaRadius, b.rotation || 0);
        });

        // Explosion
        if (state.explosion) {
          const elapsed = performance.now() - state.explosion.started;
          if (elapsed < explosionDuration) {
            const t = elapsed / explosionDuration;
            const pos = toScreen(state.explosion.x, state.explosion.y);
            const r = (40 + 40 * t) * scale;
            const grd = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, r);
            grd.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            grd.addColorStop(0.4, 'rgba(255, 180, 40, 0.8)');
            grd.addColorStop(1, 'rgba(255, 92, 0, 0)');
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Ground line
        const groundScreen = toScreen(0, world.groundY);
        ctx.fillStyle = '#0a172e';
        ctx.fillRect(0, groundScreen.y, canvas.width, canvas.height - groundScreen.y);
      }

      function drawGorillaImage(ctx, img, x, y, w, h, facing) {
        ctx.save();
        ctx.translate(x + w / 2, y + h / 2);
        ctx.scale(facing, 1);
        ctx.drawImage(img, -w / 2, -h / 2, w, h);
        ctx.restore();
      }

      function drawBanana(ctx, x, y, r, rotation) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        const len = r * 2.9;
        const width = r * 1.15;
        ctx.beginPath();
        ctx.moveTo(-len * 0.55, -width * 0.25);
        ctx.quadraticCurveTo(-len * 0.2, -width * 0.9, len * 0.15, -width * 0.75);
        ctx.quadraticCurveTo(len * 0.72, -width * 0.55, len * 0.7, -width * 0.05);
        ctx.quadraticCurveTo(len * 0.74, width * 0.45, len * 0.25, width * 0.6);
        ctx.quadraticCurveTo(-len * 0.1, width * 0.9, -len * 0.52, width * 0.25);
        ctx.quadraticCurveTo(-len * 0.68, -width * 0.05, -len * 0.55, -width * 0.25);
        ctx.closePath();
        const grad = ctx.createLinearGradient(-len * 0.6, 0, len * 0.8, 0);
        grad.addColorStop(0, '#fde047');
        grad.addColorStop(0.5, '#fbbf24');
        grad.addColorStop(1, '#f59e0b');
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.lineWidth = r * 0.16;
        ctx.strokeStyle = '#b45309';
        ctx.stroke();

        // Speckles
        ctx.fillStyle = 'rgba(146,64,14,0.6)';
        const spots = 8;
        for (let i = 0; i < spots; i++) {
          const sx = -len * 0.4 + (len * 0.8 * i) / spots;
          const sy = (Math.sin(i * 1.2) * width) / 3;
          ctx.beginPath();
          ctx.ellipse(sx, sy, r * 0.08, r * 0.12, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        // Stem
        ctx.fillStyle = '#78350f';
        ctx.beginPath();
        ctx.roundRect(len * 0.65, -width * 0.2, r * 0.4, width * 0.4, r * 0.12);
        ctx.fill();
        ctx.restore();
      }

      function createSoundPlayer() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();

        const makeNoiseBuffer = (duration) => {
          const length = Math.floor(ctx.sampleRate * duration);
          const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < length; i++) {
            data[i] = Math.random() * 2 - 1;
          }
          return buffer;
        };

        function playWhoosh() {
          const now = ctx.currentTime;
          const duration = 0.35;
          const noise = ctx.createBufferSource();
          noise.buffer = makeNoiseBuffer(duration);
          const band = ctx.createBiquadFilter();
          band.type = 'bandpass';
          band.frequency.setValueAtTime(950, now);
          band.frequency.exponentialRampToValueAtTime(480, now + duration);
          band.Q.value = 1.1;
          const gain = ctx.createGain();
          gain.gain.setValueAtTime(0.16, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
          noise.connect(band).connect(gain).connect(ctx.destination);
          noise.start(now);
          noise.stop(now + duration + 0.05);
        }

        function playExplosion(kind = 'regular') {
          const now = ctx.currentTime;
          const isBig = kind === 'big';
          const duration = isBig ? 1.1 : 0.7;

          const noise = ctx.createBufferSource();
          noise.buffer = makeNoiseBuffer(duration);
          const filter = ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(isBig ? 2600 : 2000, now);
          filter.frequency.exponentialRampToValueAtTime(isBig ? 900 : 750, now + duration * 0.5);
          const gain = ctx.createGain();
          gain.gain.setValueAtTime(isBig ? 0.85 : 0.55, now);
          gain.gain.exponentialRampToValueAtTime(0.0008, now + duration);

          // High crack layer
          const crack = ctx.createBufferSource();
          crack.buffer = makeNoiseBuffer(0.18);
          const crackFilter = ctx.createBiquadFilter();
          crackFilter.type = 'highpass';
          crackFilter.frequency.setValueAtTime(2800, now);
          const crackGain = ctx.createGain();
          crackGain.gain.setValueAtTime(isBig ? 0.28 : 0.2, now);
          crackGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);

          // Low boom sine for big hits
          let boomOsc = null;
          let boomGain = null;
          if (isBig) {
            boomOsc = ctx.createOscillator();
            boomOsc.type = 'sine';
            boomOsc.frequency.setValueAtTime(70, now);
            boomOsc.frequency.exponentialRampToValueAtTime(45, now + 0.5);
            boomGain = ctx.createGain();
            boomGain.gain.setValueAtTime(0.5, now);
            boomGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
            boomOsc.connect(boomGain).connect(ctx.destination);
          }

          noise.connect(filter).connect(gain).connect(ctx.destination);
          crack.connect(crackFilter).connect(crackGain).connect(ctx.destination);

          noise.start(now);
          noise.stop(now + duration + 0.1);
          crack.start(now);
          crack.stop(now + 0.25);
          if (boomOsc && boomGain) {
            boomOsc.start(now);
            boomOsc.stop(now + 0.65);
          }
        }

        return {
          play: (name) => {
            if (name === 'whoosh') playWhoosh();
            if (name === 'explosion') playExplosion('regular');
            if (name === 'bigExplosion') playExplosion('big');
          }
        };
      }

      function createGorillaSprites() {
        const makeSprite = (accentPrimary, accentSecondary) => {
          const canvas = document.createElement('canvas');
          canvas.width = 360;
          canvas.height = 440;
          const c = canvas.getContext('2d');
          c.translate(canvas.width / 2, canvas.height - 32);

          // Shadow
          const shadowGrad = c.createRadialGradient(0, 8, 8, 0, 8, 120);
          shadowGrad.addColorStop(0, 'rgba(0,0,0,0.38)');
          shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
          c.fillStyle = shadowGrad;
          c.beginPath();
          c.ellipse(0, 10, 120, 22, 0, 0, Math.PI * 2);
          c.fill();

          // Torso
          const torsoGrad = c.createLinearGradient(0, -280, 0, 40);
          torsoGrad.addColorStop(0, '#3f3f45');
          torsoGrad.addColorStop(0.35, '#2f2f34');
          torsoGrad.addColorStop(1, '#1b1b1f');
          c.fillStyle = torsoGrad;
          c.beginPath();
          c.moveTo(-90, -250);
          c.bezierCurveTo(-140, -190, -150, -40, -120, 40);
          c.bezierCurveTo(-94, 110, 94, 110, 120, 40);
          c.bezierCurveTo(150, -40, 140, -190, 90, -250);
          c.closePath();
          c.fill();

          // Chest highlight
          const chestGrad = c.createRadialGradient(0, -120, 20, 0, -120, 120);
          chestGrad.addColorStop(0, 'rgba(206,200,180,0.65)');
          chestGrad.addColorStop(0.4, 'rgba(206,200,180,0.38)');
          chestGrad.addColorStop(1, 'rgba(206,200,180,0)');
          c.fillStyle = chestGrad;
          c.beginPath();
          c.ellipse(0, -120, 70, 90, 0, 0, Math.PI * 2);
          c.fill();

          // Legs
          c.fillStyle = '#19191d';
          c.beginPath();
          c.roundRect(-82, -42, 62, 128, 24);
          c.roundRect(20, -42, 62, 128, 24);
          c.fill();

          // Feet
          c.fillStyle = '#3a3630';
          c.beginPath();
          c.ellipse(-52, 88, 44, 18, 0, 0, Math.PI * 2);
          c.ellipse(52, 88, 44, 18, 0, 0, Math.PI * 2);
          c.fill();

          // Arms
          c.fillStyle = '#25252b';
          c.beginPath();
          c.moveTo(-150, -120);
          c.bezierCurveTo(-118, -90, -40, -20, -20, 22);
          c.bezierCurveTo(-8, 48, -26, 80, -50, 88);
          c.bezierCurveTo(-92, 70, -150, 22, -170, -48);
          c.closePath();
          c.fill();
          c.beginPath();
          c.moveTo(150, -120);
          c.bezierCurveTo(118, -90, 40, -20, 20, 22);
          c.bezierCurveTo(8, 48, 26, 80, 50, 88);
          c.bezierCurveTo(92, 70, 150, 22, 170, -48);
          c.closePath();
          c.fill();

          // Accent wraps
          c.fillStyle = accentPrimary;
          c.fillRect(-38, 24, 16, 18);
          c.fillRect(22, 24, 16, 18);
          c.fillStyle = accentSecondary;
          c.fillRect(-38, 40, 16, 10);
          c.fillRect(22, 40, 16, 10);

          // Head
          const headGrad = c.createLinearGradient(0, -320, 0, -200);
          headGrad.addColorStop(0, '#46494f');
          headGrad.addColorStop(1, '#2a2d33');
          c.fillStyle = headGrad;
          c.beginPath();
          c.ellipse(0, -250, 64, 58, 0, 0, Math.PI * 2);
          c.fill();

          // Brow band
          c.fillStyle = '#1a1b1f';
          c.beginPath();
          c.ellipse(0, -268, 70, 18, 0, 0, Math.PI * 2);
          c.fill();

          // Face
          const faceGrad = c.createLinearGradient(0, -240, 0, -200);
          faceGrad.addColorStop(0, '#d5d5d0');
          faceGrad.addColorStop(1, '#9c9c96');
          c.fillStyle = faceGrad;
          c.beginPath();
          c.moveTo(-42, -220);
          c.bezierCurveTo(-30, -240, -20, -244, 0, -244);
          c.bezierCurveTo(20, -244, 30, -240, 42, -220);
          c.bezierCurveTo(44, -198, 36, -176, 0, -176);
          c.bezierCurveTo(-36, -176, -44, -198, -42, -220);
          c.closePath();
          c.fill();

          // Eyes
          c.fillStyle = '#0f0f12';
          c.beginPath();
          c.ellipse(-18, -230, 9, 9, 0, 0, Math.PI * 2);
          c.ellipse(18, -230, 9, 9, 0, 0, Math.PI * 2);
          c.fill();
          c.fillStyle = 'white';
          c.beginPath();
          c.ellipse(-15, -232, 3, 3, 0, 0, Math.PI * 2);
          c.ellipse(21, -232, 3, 3, 0, 0, Math.PI * 2);
          c.fill();

          // Nose and mouth
          c.strokeStyle = '#0f0f12';
          c.lineWidth = 3;
          c.lineCap = 'round';
          c.beginPath();
          c.moveTo(-8, -210);
          c.quadraticCurveTo(0, -206, 8, -210);
          c.stroke();
          c.beginPath();
          c.moveTo(-18, -198);
          c.quadraticCurveTo(0, -192, 18, -198);
          c.stroke();

          // Fur edge texture
          c.strokeStyle = 'rgba(255,255,255,0.08)';
          c.lineWidth = 2;
          for (let i = -80; i <= 80; i += 16) {
            c.beginPath();
            c.moveTo(i, -220);
            c.lineTo(i + rand(-6, 6), -200 + rand(-6, 6));
            c.stroke();
          }

          const img = new Image();
          img.src = canvas.toDataURL('image/png');
          return img;
        };

        return {
          p1: makeSprite('#fbbf24', '#f97316'),
          p2: makeSprite('#60a5fa', '#22d3ee')
        };
      }

      function maybeTriggerAI() {
        if (aiTimeout) {
          clearTimeout(aiTimeout);
          aiTimeout = null;
        }
        if (arcadeOverlayVisible) return;
        const thinkDelay = isDemoMode() ? 120 : 500;
        if (settings.counterfire && isDemoMode()) {
          if (!state.roundActive || state.inFlight) return;
          setSettingsEnabled(false);
          setControlsEnabled(false);
          aiTimeout = setTimeout(() => {
            aiTimeout = null;
            if (!state.roundActive || state.inFlight) return;
            const shot1 = planAiShotFor(1);
            const shot2 = planAiShotFor(2);
            if (!shot1 || !shot2) return;
            pendingCounterfireShots[1] = shot1;
            pendingCounterfireShots[2] = shot2;
            lastShot[1] = { angle: Math.round(shot1.angle), velocity: Math.round(shot1.velocity) };
            lastShot[2] = { angle: Math.round(shot2.angle), velocity: Math.round(shot2.velocity) };
            counterfireActiveEntry = 1;
            refreshCounterfireUI();
            launchCounterfireShots();
          }, thinkDelay);
          return;
        }
        const player = state.currentPlayer;
        if (!shouldAiControlPlayer(player)) return;
        setSettingsEnabled(false);
        setControlsEnabled(false);
        aiTimeout = setTimeout(() => {
          aiTimeout = null;
          if (!shouldAiControlPlayer(player)) return;
          const shooterIndex = player - 1;
          const targetIndex = shooterIndex === 0 ? 1 : 0;
          const shooter = state.gorillas[shooterIndex];
          const target = state.gorillas[targetIndex];
          if (!shooter || !target) return;
          if (aiPlans[player].length === 0) {
            aiPlans[player] = buildAiPlan(shooter, target);
          }
          const shotList = aiPlans[player];
          const shot = shotList.shift() || computeOptimalShot(shooter, target);
          fireShot(shot.angle, shot.velocity);
        }, thinkDelay);
      }

      controlForm.addEventListener('submit', handleControlSubmit);
      newRoundBtn.addEventListener('click', handleNewRound);
      resetScoresBtn.addEventListener('click', handleResetScores);
      Object.values(counterfirePanels).forEach(panel => {
        linkInputPair(panel.angleInput, panel.angleSlider);
        linkInputPair(panel.velocityInput, panel.velocitySlider);
      });
      counterfirePanels[1].button.addEventListener('click', () => handlePlayerThrow(1));
      counterfirePanels[2].button.addEventListener('click', () => handlePlayerThrow(2));
      counterfireToggle.addEventListener('change', () => {
        if (!modeAllowsCounterfire()) {
          counterfireToggle.checked = false;
          return;
        }
        settings.counterfire = counterfireToggle.checked;
        resetCounterfireEntry();
        updateModeDependentControls();
      });
      helpButton.addEventListener('click', showHelpModal);
      helpModalClose.addEventListener('click', hideHelpModal);
      helpModal.addEventListener('click', (event) => {
        if (event.target === helpModal) {
          hideHelpModal();
        }
      });
      statsButton.addEventListener('click', openStatsModal);
      statsModalClose.addEventListener('click', closeStatsModal);
      statsModal.addEventListener('click', (event) => {
        if (event.target === statsModal) {
          closeStatsModal();
        }
      });
      arcadeRestartBtn.addEventListener('click', handleArcadeRestart);
      arcadeCloseBtn.addEventListener('click', closeArcadeOverlay);
      arcadeOverlay.addEventListener('click', (event) => {
        if (event.target === arcadeOverlay) {
          closeArcadeOverlay();
        }
      });
      document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'r') handleNewRound();
        if (e.key === 'Escape') {
          if (statsModalOpen) {
            closeStatsModal();
            return;
          }
          if (arcadeOverlayVisible) {
            closeArcadeOverlay();
            return;
          }
          hideHelpModal();
          if (isDemoMode()) {
            handleGameModeChange(lastManualMode || 'classic');
          }
          return;
        }
        if (e.key !== 'Enter') return;
        const activeEl = document.activeElement;
        if (activeEl && activeEl.tagName === 'BUTTON') return;
        e.preventDefault();
        if (settings.counterfire) {
          const panelOwner = activeEl && typeof activeEl.closest === 'function'
            ? activeEl.closest('.player-panel')
            : null;
          let player = panelOwner ? Number(panelOwner.dataset.player) : counterfireActiveEntry;
          if (Number.isNaN(player)) player = counterfireActiveEntry;
          handlePlayerThrow(player);
        } else {
          handlePlayerThrow(state.currentPlayer);
        }
      });

      opponentSelect.addEventListener('change', () => {
        if (!isClassicMode()) {
          opponentSelect.value = 'ai';
          setMessage('Opponent locked to AI in this mode.');
          return;
        }
        settings.opponentType = opponentSelect.value;
        resetAiPlans();
        if (state.shotsTakenThisRound === 0) {
          setMessage('Opponent updated.');
        } else {
          regenerateRound(true, { force: true });
        }
        enforceModeConstraints();
        updateModeDependentControls();
        refreshCounterfireUI();
        maybeTriggerAI();
      });
      gameModeRadios.forEach(radio => {
        radio.addEventListener('change', (event) => {
          handleGameModeChange(event.target.value);
        });
      });
      aiDifficultySelect.addEventListener('change', () => {
        settings.aiDifficulty = aiDifficultySelect.value;
        if (state.shotsTakenThisRound === 0) {
          setMessage('AI difficulty updated.');
        } else {
          regenerateRound(true, { force: true });
        }
      });
      gravitySelect.addEventListener('change', () => {
        settings.gravityLevel = gravitySelect.value;
        if (state.shotsTakenThisRound === 0) {
          setMessage('Gravity updated.');
        } else {
          regenerateRound(true, { force: true });
        }
      });
      windSelect.addEventListener('change', () => {
        settings.windMode = windSelect.value;
        if (state.shotsTakenThisRound === 0) {
          const windBound = windLevels[settings.windMode];
          state.wind = windBound === 0 ? 0 : rand(-windBound, windBound);
          updateHUD();
          setMessage('Wind updated.');
        } else {
          regenerateRound(true, { force: true });
        }
      });
      varianceSelect.addEventListener('change', () => {
        settings.skylineVariance = varianceSelect.value;
        regenerateRound(false, { force: true });
      });
      muteToggle.addEventListener('change', () => {
        setMessage(muteToggle.checked ? 'Sounds muted' : 'Sounds on');
      });

      sidebarToggle.addEventListener('click', () => {
        sidebar.classList.toggle('open');
      });
      sidebar.addEventListener('click', (e) => {
        if (e.target === sidebar && sidebar.classList.contains('open')) {
          sidebar.classList.remove('open');
        }
      });

      enforceModeConstraints();
      regenerateRound(true, { force: true });
      refreshCounterfireUI();
      requestAnimationFrame(step);
    })();
  </script>
</body>

</html>
